<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>

<title>Contents {#contents}</title>

<script type="text/javascript">
window.onload = function() {
  var imgs = document.getElementsByTagName('img'), i, img;
  for (i = 0; i < imgs.length; i++) {
    img = imgs[i];
    // center an image if it is the only element of its parent
    if (img.parentElement.childElementCount === 1)
      img.parentElement.style.textAlign = 'center';
  }
};
</script>

<!-- Styles for R syntax highlighter -->
<style type="text/css">
   pre .operator,
   pre .paren {
     color: rgb(104, 118, 135)
   }

   pre .literal {
     color: #990073
   }

   pre .number {
     color: #099;
   }

   pre .comment {
     color: #998;
     font-style: italic
   }

   pre .keyword {
     color: #900;
     font-weight: bold
   }

   pre .identifier {
     color: rgb(0, 0, 0);
   }

   pre .string {
     color: #d14;
   }
</style>

<!-- R syntax highlighter -->
<script type="text/javascript">
var hljs=new function(){function m(p){return p.replace(/&/gm,"&amp;").replace(/</gm,"&lt;")}function f(r,q,p){return RegExp(q,"m"+(r.cI?"i":"")+(p?"g":""))}function b(r){for(var p=0;p<r.childNodes.length;p++){var q=r.childNodes[p];if(q.nodeName=="CODE"){return q}if(!(q.nodeType==3&&q.nodeValue.match(/\s+/))){break}}}function h(t,s){var p="";for(var r=0;r<t.childNodes.length;r++){if(t.childNodes[r].nodeType==3){var q=t.childNodes[r].nodeValue;if(s){q=q.replace(/\n/g,"")}p+=q}else{if(t.childNodes[r].nodeName=="BR"){p+="\n"}else{p+=h(t.childNodes[r])}}}if(/MSIE [678]/.test(navigator.userAgent)){p=p.replace(/\r/g,"\n")}return p}function a(s){var r=s.className.split(/\s+/);r=r.concat(s.parentNode.className.split(/\s+/));for(var q=0;q<r.length;q++){var p=r[q].replace(/^language-/,"");if(e[p]){return p}}}function c(q){var p=[];(function(s,t){for(var r=0;r<s.childNodes.length;r++){if(s.childNodes[r].nodeType==3){t+=s.childNodes[r].nodeValue.length}else{if(s.childNodes[r].nodeName=="BR"){t+=1}else{if(s.childNodes[r].nodeType==1){p.push({event:"start",offset:t,node:s.childNodes[r]});t=arguments.callee(s.childNodes[r],t);p.push({event:"stop",offset:t,node:s.childNodes[r]})}}}}return t})(q,0);return p}function k(y,w,x){var q=0;var z="";var s=[];function u(){if(y.length&&w.length){if(y[0].offset!=w[0].offset){return(y[0].offset<w[0].offset)?y:w}else{return w[0].event=="start"?y:w}}else{return y.length?y:w}}function t(D){var A="<"+D.nodeName.toLowerCase();for(var B=0;B<D.attributes.length;B++){var C=D.attributes[B];A+=" "+C.nodeName.toLowerCase();if(C.value!==undefined&&C.value!==false&&C.value!==null){A+='="'+m(C.value)+'"'}}return A+">"}while(y.length||w.length){var v=u().splice(0,1)[0];z+=m(x.substr(q,v.offset-q));q=v.offset;if(v.event=="start"){z+=t(v.node);s.push(v.node)}else{if(v.event=="stop"){var p,r=s.length;do{r--;p=s[r];z+=("</"+p.nodeName.toLowerCase()+">")}while(p!=v.node);s.splice(r,1);while(r<s.length){z+=t(s[r]);r++}}}}return z+m(x.substr(q))}function j(){function q(x,y,v){if(x.compiled){return}var u;var s=[];if(x.k){x.lR=f(y,x.l||hljs.IR,true);for(var w in x.k){if(!x.k.hasOwnProperty(w)){continue}if(x.k[w] instanceof Object){u=x.k[w]}else{u=x.k;w="keyword"}for(var r in u){if(!u.hasOwnProperty(r)){continue}x.k[r]=[w,u[r]];s.push(r)}}}if(!v){if(x.bWK){x.b="\\b("+s.join("|")+")\\s"}x.bR=f(y,x.b?x.b:"\\B|\\b");if(!x.e&&!x.eW){x.e="\\B|\\b"}if(x.e){x.eR=f(y,x.e)}}if(x.i){x.iR=f(y,x.i)}if(x.r===undefined){x.r=1}if(!x.c){x.c=[]}x.compiled=true;for(var t=0;t<x.c.length;t++){if(x.c[t]=="self"){x.c[t]=x}q(x.c[t],y,false)}if(x.starts){q(x.starts,y,false)}}for(var p in e){if(!e.hasOwnProperty(p)){continue}q(e[p].dM,e[p],true)}}function d(B,C){if(!j.called){j();j.called=true}function q(r,M){for(var L=0;L<M.c.length;L++){if((M.c[L].bR.exec(r)||[null])[0]==r){return M.c[L]}}}function v(L,r){if(D[L].e&&D[L].eR.test(r)){return 1}if(D[L].eW){var M=v(L-1,r);return M?M+1:0}return 0}function w(r,L){return L.i&&L.iR.test(r)}function K(N,O){var M=[];for(var L=0;L<N.c.length;L++){M.push(N.c[L].b)}var r=D.length-1;do{if(D[r].e){M.push(D[r].e)}r--}while(D[r+1].eW);if(N.i){M.push(N.i)}return f(O,M.join("|"),true)}function p(M,L){var N=D[D.length-1];if(!N.t){N.t=K(N,E)}N.t.lastIndex=L;var r=N.t.exec(M);return r?[M.substr(L,r.index-L),r[0],false]:[M.substr(L),"",true]}function z(N,r){var L=E.cI?r[0].toLowerCase():r[0];var M=N.k[L];if(M&&M instanceof Array){return M}return false}function F(L,P){L=m(L);if(!P.k){return L}var r="";var O=0;P.lR.lastIndex=0;var M=P.lR.exec(L);while(M){r+=L.substr(O,M.index-O);var N=z(P,M);if(N){x+=N[1];r+='<span class="'+N[0]+'">'+M[0]+"</span>"}else{r+=M[0]}O=P.lR.lastIndex;M=P.lR.exec(L)}return r+L.substr(O,L.length-O)}function J(L,M){if(M.sL&&e[M.sL]){var r=d(M.sL,L);x+=r.keyword_count;return r.value}else{return F(L,M)}}function I(M,r){var L=M.cN?'<span class="'+M.cN+'">':"";if(M.rB){y+=L;M.buffer=""}else{if(M.eB){y+=m(r)+L;M.buffer=""}else{y+=L;M.buffer=r}}D.push(M);A+=M.r}function G(N,M,Q){var R=D[D.length-1];if(Q){y+=J(R.buffer+N,R);return false}var P=q(M,R);if(P){y+=J(R.buffer+N,R);I(P,M);return P.rB}var L=v(D.length-1,M);if(L){var O=R.cN?"</span>":"";if(R.rE){y+=J(R.buffer+N,R)+O}else{if(R.eE){y+=J(R.buffer+N,R)+O+m(M)}else{y+=J(R.buffer+N+M,R)+O}}while(L>1){O=D[D.length-2].cN?"</span>":"";y+=O;L--;D.length--}var r=D[D.length-1];D.length--;D[D.length-1].buffer="";if(r.starts){I(r.starts,"")}return R.rE}if(w(M,R)){throw"Illegal"}}var E=e[B];var D=[E.dM];var A=0;var x=0;var y="";try{var s,u=0;E.dM.buffer="";do{s=p(C,u);var t=G(s[0],s[1],s[2]);u+=s[0].length;if(!t){u+=s[1].length}}while(!s[2]);if(D.length>1){throw"Illegal"}return{r:A,keyword_count:x,value:y}}catch(H){if(H=="Illegal"){return{r:0,keyword_count:0,value:m(C)}}else{throw H}}}function g(t){var p={keyword_count:0,r:0,value:m(t)};var r=p;for(var q in e){if(!e.hasOwnProperty(q)){continue}var s=d(q,t);s.language=q;if(s.keyword_count+s.r>r.keyword_count+r.r){r=s}if(s.keyword_count+s.r>p.keyword_count+p.r){r=p;p=s}}if(r.language){p.second_best=r}return p}function i(r,q,p){if(q){r=r.replace(/^((<[^>]+>|\t)+)/gm,function(t,w,v,u){return w.replace(/\t/g,q)})}if(p){r=r.replace(/\n/g,"<br>")}return r}function n(t,w,r){var x=h(t,r);var v=a(t);var y,s;if(v){y=d(v,x)}else{return}var q=c(t);if(q.length){s=document.createElement("pre");s.innerHTML=y.value;y.value=k(q,c(s),x)}y.value=i(y.value,w,r);var u=t.className;if(!u.match("(\\s|^)(language-)?"+v+"(\\s|$)")){u=u?(u+" "+v):v}if(/MSIE [678]/.test(navigator.userAgent)&&t.tagName=="CODE"&&t.parentNode.tagName=="PRE"){s=t.parentNode;var p=document.createElement("div");p.innerHTML="<pre><code>"+y.value+"</code></pre>";t=p.firstChild.firstChild;p.firstChild.cN=s.cN;s.parentNode.replaceChild(p.firstChild,s)}else{t.innerHTML=y.value}t.className=u;t.result={language:v,kw:y.keyword_count,re:y.r};if(y.second_best){t.second_best={language:y.second_best.language,kw:y.second_best.keyword_count,re:y.second_best.r}}}function o(){if(o.called){return}o.called=true;var r=document.getElementsByTagName("pre");for(var p=0;p<r.length;p++){var q=b(r[p]);if(q){n(q,hljs.tabReplace)}}}function l(){if(window.addEventListener){window.addEventListener("DOMContentLoaded",o,false);window.addEventListener("load",o,false)}else{if(window.attachEvent){window.attachEvent("onload",o)}else{window.onload=o}}}var e={};this.LANGUAGES=e;this.highlight=d;this.highlightAuto=g;this.fixMarkup=i;this.highlightBlock=n;this.initHighlighting=o;this.initHighlightingOnLoad=l;this.IR="[a-zA-Z][a-zA-Z0-9_]*";this.UIR="[a-zA-Z_][a-zA-Z0-9_]*";this.NR="\\b\\d+(\\.\\d+)?";this.CNR="\\b(0[xX][a-fA-F0-9]+|(\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)";this.BNR="\\b(0b[01]+)";this.RSR="!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|\\.|-|-=|/|/=|:|;|<|<<|<<=|<=|=|==|===|>|>=|>>|>>=|>>>|>>>=|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~";this.ER="(?![\\s\\S])";this.BE={b:"\\\\.",r:0};this.ASM={cN:"string",b:"'",e:"'",i:"\\n",c:[this.BE],r:0};this.QSM={cN:"string",b:'"',e:'"',i:"\\n",c:[this.BE],r:0};this.CLCM={cN:"comment",b:"//",e:"$"};this.CBLCLM={cN:"comment",b:"/\\*",e:"\\*/"};this.HCM={cN:"comment",b:"#",e:"$"};this.NM={cN:"number",b:this.NR,r:0};this.CNM={cN:"number",b:this.CNR,r:0};this.BNM={cN:"number",b:this.BNR,r:0};this.inherit=function(r,s){var p={};for(var q in r){p[q]=r[q]}if(s){for(var q in s){p[q]=s[q]}}return p}}();hljs.LANGUAGES.cpp=function(){var a={keyword:{"false":1,"int":1,"float":1,"while":1,"private":1,"char":1,"catch":1,"export":1,virtual:1,operator:2,sizeof:2,dynamic_cast:2,typedef:2,const_cast:2,"const":1,struct:1,"for":1,static_cast:2,union:1,namespace:1,unsigned:1,"long":1,"throw":1,"volatile":2,"static":1,"protected":1,bool:1,template:1,mutable:1,"if":1,"public":1,friend:2,"do":1,"return":1,"goto":1,auto:1,"void":2,"enum":1,"else":1,"break":1,"new":1,extern:1,using:1,"true":1,"class":1,asm:1,"case":1,typeid:1,"short":1,reinterpret_cast:2,"default":1,"double":1,register:1,explicit:1,signed:1,typename:1,"try":1,"this":1,"switch":1,"continue":1,wchar_t:1,inline:1,"delete":1,alignof:1,char16_t:1,char32_t:1,constexpr:1,decltype:1,noexcept:1,nullptr:1,static_assert:1,thread_local:1,restrict:1,_Bool:1,complex:1},built_in:{std:1,string:1,cin:1,cout:1,cerr:1,clog:1,stringstream:1,istringstream:1,ostringstream:1,auto_ptr:1,deque:1,list:1,queue:1,stack:1,vector:1,map:1,set:1,bitset:1,multiset:1,multimap:1,unordered_set:1,unordered_map:1,unordered_multiset:1,unordered_multimap:1,array:1,shared_ptr:1}};return{dM:{k:a,i:"</",c:[hljs.CLCM,hljs.CBLCLM,hljs.QSM,{cN:"string",b:"'\\\\?.",e:"'",i:"."},{cN:"number",b:"\\b(\\d+(\\.\\d*)?|\\.\\d+)(u|U|l|L|ul|UL|f|F)"},hljs.CNM,{cN:"preprocessor",b:"#",e:"$"},{cN:"stl_container",b:"\\b(deque|list|queue|stack|vector|map|set|bitset|multiset|multimap|unordered_map|unordered_set|unordered_multiset|unordered_multimap|array)\\s*<",e:">",k:a,r:10,c:["self"]}]}}}();hljs.LANGUAGES.r={dM:{c:[hljs.HCM,{cN:"number",b:"\\b0[xX][0-9a-fA-F]+[Li]?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+(?:[eE][+\\-]?\\d*)?L\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+\\.(?!\\d)(?:i\\b)?",e:hljs.IMMEDIATE_RE,r:1},{cN:"number",b:"\\b\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\.\\d+(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"keyword",b:"(?:tryCatch|library|setGeneric|setGroupGeneric)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\.",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\d+(?![\\w.])",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\b(?:function)",e:hljs.IMMEDIATE_RE,r:2},{cN:"keyword",b:"(?:if|in|break|next|repeat|else|for|return|switch|while|try|stop|warning|require|attach|detach|source|setMethod|setClass)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"literal",b:"(?:NA|NA_integer_|NA_real_|NA_character_|NA_complex_)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"literal",b:"(?:NULL|TRUE|FALSE|T|F|Inf|NaN)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"identifier",b:"[a-zA-Z.][a-zA-Z0-9._]*\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"<\\-(?!\\s*\\d)",e:hljs.IMMEDIATE_RE,r:2},{cN:"operator",b:"\\->|<\\-",e:hljs.IMMEDIATE_RE,r:1},{cN:"operator",b:"%%|~",e:hljs.IMMEDIATE_RE},{cN:"operator",b:">=|<=|==|!=|\\|\\||&&|=|\\+|\\-|\\*|/|\\^|>|<|!|&|\\||\\$|:",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"%",e:"%",i:"\\n",r:1},{cN:"identifier",b:"`",e:"`",r:0},{cN:"string",b:'"',e:'"',c:[hljs.BE],r:0},{cN:"string",b:"'",e:"'",c:[hljs.BE],r:0},{cN:"paren",b:"[[({\\])}]",e:hljs.IMMEDIATE_RE,r:0}]}};
hljs.initHighlightingOnLoad();
</script>

<!-- MathJax scripts -->
<script type="text/javascript" src="https://cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML">
</script>


<style type="text/css">
body, td {
   font-family: sans-serif;
   background-color: white;
   font-size: 13px;
}

body {
  max-width: 800px;
  margin: auto;
  padding: 1em;
  line-height: 20px;
}

tt, code, pre {
   font-family: 'DejaVu Sans Mono', 'Droid Sans Mono', 'Lucida Console', Consolas, Monaco, monospace;
}

h1 {
   font-size:2.2em;
}

h2 {
   font-size:1.8em;
}

h3 {
   font-size:1.4em;
}

h4 {
   font-size:1.0em;
}

h5 {
   font-size:0.9em;
}

h6 {
   font-size:0.8em;
}

a:visited {
   color: rgb(50%, 0%, 50%);
}

pre, img {
  max-width: 100%;
}
pre {
  overflow-x: auto;
}
pre code {
   display: block; padding: 0.5em;
}

code {
  font-size: 92%;
  border: 1px solid #ccc;
}

code[class] {
  background-color: #F8F8F8;
}

table, td, th {
  border: none;
}

blockquote {
   color:#666666;
   margin:0;
   padding-left: 1em;
   border-left: 0.5em #EEE solid;
}

hr {
   height: 0px;
   border-bottom: none;
   border-top-width: thin;
   border-top-style: dotted;
   border-top-color: #999999;
}

@media print {
   * {
      background: transparent !important;
      color: black !important;
      filter:none !important;
      -ms-filter: none !important;
   }

   body {
      font-size:12pt;
      max-width:100%;
   }

   a, a:visited {
      text-decoration: underline;
   }

   hr {
      visibility: hidden;
      page-break-before: always;
   }

   pre, blockquote {
      padding-right: 1em;
      page-break-inside: avoid;
   }

   tr, img {
      page-break-inside: avoid;
   }

   img {
      max-width: 100% !important;
   }

   @page :left {
      margin: 15mm 20mm 15mm 10mm;
   }

   @page :right {
      margin: 15mm 10mm 15mm 20mm;
   }

   p, h2, h3 {
      orphans: 3; widows: 3;
   }

   h2, h3 {
      page-break-after: avoid;
   }
}
</style>



</head>

<body>
<!-- @index Vignettes!Transformations and link functions -->

<h2>Contents {#contents}</h2>

<p>This vignette covers the intricacies of transformations and link functions in <strong>emmeans</strong>.</p>

<ol>
<li><a href="#overview">Overview</a></li>
<li><a href="#regrid">Re-gridding</a></li>
<li><a href="#links">Link functions</a></li>
<li><a href="#tranlink">Both a response transformation and a link</a></li>
<li><a href="#special">Special transformations</a></li>
<li><a href="#after">Specifying a transformation after the fact</a></li>
<li><a href="#logs">Faking a log transformation</a></li>
<li><a href="#bias-adj">Bias adjustment</a></li>
</ol>

<p><a href="vignette-topics.html">Index of all vignette topics</a> </p>

<h2>Overview {#overview}</h2>

<!-- @index Transformations!Overview -->

<p>Consider the same example with the <code>pigs</code> dataset that is used in many of 
these vignettes:</p>

<pre><code class="r">pigs.lm &lt;- lm(log(conc) ~ source + factor(percent), data = pigs)
</code></pre>

<p>This model has two factors, <code>source</code> and <code>percent</code> (coerced to a factor), as 
predictors; and log-transformed <code>conc</code> as the response. Here we obtain the EMMs
for <code>source</code>, examine its structure, and finally produce a summary, including a
test against a null value of log(35):</p>

<pre><code class="r">pigs.emm.s &lt;- emmeans(pigs.lm, &quot;source&quot;)
str(pigs.emm.s)
</code></pre>

<pre><code class="ro">## &#39;emmGrid&#39; object with variables:
##     source = fish, soy, skim
## Transformation: &quot;log&quot;
</code></pre>

<pre><code class="r">summary(pigs.emm.s, infer = TRUE, null = log(35))
</code></pre>

<pre><code class="ro">##  source emmean     SE df lower.CL upper.CL null t.ratio p.value
##  fish     3.39 0.0367 23     3.32     3.47 3.56 -4.385  0.0002 
##  soy      3.67 0.0374 23     3.59     3.74 3.56  2.988  0.0066 
##  skim     3.80 0.0394 23     3.72     3.88 3.56  6.130  &lt;.0001 
## 
## Results are averaged over the levels of: percent 
## Results are given on the log (not the response) scale. 
## Confidence level used: 0.95
</code></pre>

<p>Now suppose that we want the EMMs expressed on the same scale as <code>conc</code>. This 
can be done by adding <code>type = &quot;response&quot;</code> to the <code>summary()</code> call: </p>

<pre><code class="r">summary(pigs.emm.s, infer = TRUE, null = log(35), type = &quot;response&quot;)
</code></pre>

<pre><code class="ro">##  source response   SE df lower.CL upper.CL null t.ratio p.value
##  fish       29.8 1.09 23     27.6     32.1   35 -4.385  0.0002 
##  soy        39.1 1.47 23     36.2     42.3   35  2.988  0.0066 
##  skim       44.6 1.75 23     41.1     48.3   35  6.130  &lt;.0001 
## 
## Results are averaged over the levels of: percent 
## Confidence level used: 0.95 
## Intervals are back-transformed from the log scale 
## Tests are performed on the log scale
</code></pre>

<h3>Timing is everything {#timing}</h3>

<!-- @index Transformations!Timing is everything -->

<p>Dealing with transformations in <strong>emmeans</strong> is somewhat complex, due to the 
large number of possibilities. But the key is understanding what happens, when.
These results come from a sequence of steps. Here is what happens (and doesn&#39;t
happen) at each step:</p>

<ol>
<li>The reference grid is constructed for the <code>log(conc)</code> model. The
 fact that a log transformation is used is recorded, but nothing else
 is done with that information.</li>
<li>The predictions on the reference grid are averaged
 over the four <code>percent</code> levels, for each <code>source</code>, to obtain the EMMs
 for <code>source</code> &ndash; <em>still</em> on the <code>log(conc)</code> scale.</li>
<li>The standard errors and confidence intervals for these EMMs are
 computed &ndash; <em>still</em> on the <code>log(conc)</code> scale.</li>
<li>Only now do we do back-transformation&hellip;
 a. The EMMs are back-transformed to the <code>conc</code> scale.
 b. The endpoints of the confidence intervals are back-transformed.
 c. The <em>t</em> tests and <em>P</em> values are left as-is.
 d. The standard errors are converted to the <code>conc</code> scale using the
    delta method. These SEs were <em>not</em> used in constructing the 
    tests and confidence intervals.</li>
</ol>

<h3>The model is our best guide</h3>

<p>This choice of timing is based on the idea that <em>the model is right</em>. In
particular, the fact that the response is transformed suggests that the
transformed scale is the best scale to be working with. In addition, the model
specifies that the effects of <code>source</code> and <code>percent</code> are <em>linear</em> on the
transformed scale; inasmuch as marginal averaging to obtain EMMs is a linear
operation, that averaging is best done on the transformed scale. For those two
good reasons, back-transforming to the response scale is delayed until the very
end by default.</p>

<p><a href="#contents">Back to Contents</a></p>

<h2>Re-gridding {#regrid}</h2>

<!-- @index `regrid()`; Transformations!Re-gridding; `emmeans()`!With transformations -->

<p>As well-advised as it is, some users may not want the default timing of things.
The tool for changing when back-transformation is performed is the <code>regrid()</code>
function &ndash; which, with default settings of its arguments, back-transforms an
<code>emmGrid</code> object and adjusts everything in it appropriately. For example:</p>

<pre><code class="r">str(regrid(pigs.emm.s))
</code></pre>

<pre><code class="ro">## &#39;emmGrid&#39; object with variables:
##     source = fish, soy, skim
</code></pre>

<pre><code class="r">summary(regrid(pigs.emm.s), infer = TRUE, null = 35)
</code></pre>

<pre><code class="ro">##  source response   SE df lower.CL upper.CL null t.ratio p.value
##  fish       29.8 1.09 23     27.5     32.1   35 -4.758  0.0001 
##  soy        39.1 1.47 23     36.1     42.2   35  2.827  0.0096 
##  skim       44.6 1.75 23     40.9     48.2   35  5.446  &lt;.0001 
## 
## Results are averaged over the levels of: percent 
## Confidence level used: 0.95
</code></pre>

<p>Notice that the structure no longer includes the transformation. That&#39;s because
it is no longer relevant; the reference grid is on the <code>conc</code> scale, and how we got there is now forgotten. Compare this <code>summary()</code> result with the preceding one, and note the following:</p>

<ul>
<li>It no longer has annotations concerning transformations.</li>
<li>The estimates and SEs are identical.</li>
<li>The confidence intervals, <em>t</em> ratios, and <em>P</em> values are <em>not</em>
identical. This is because, this time, the SEs shown in the table
are the ones actually used to construct the tests and intervals.</li>
</ul>

<p>Understood, right? But think carefully about how these EMMs were obtained. 
They are back-transformed from <code>pigs.emm.s</code>, in which <em>the marginal averaging
was done on the log scale</em>. If we want to back-transform <em>before</em> doing the
averaging, we need to call <code>regrid()</code> after the reference grid is constructed but
before the averaging takes place:</p>

<pre><code class="r">pigs.rg &lt;- ref_grid(pigs.lm)
pigs.remm.s &lt;- emmeans(regrid(pigs.rg), &quot;source&quot;)
summary(pigs.remm.s, infer = TRUE, null = 35)
</code></pre>

<pre><code class="ro">##  source response   SE df lower.CL upper.CL null t.ratio p.value
##  fish       30.0 1.10 23     27.7     32.2   35 -4.585  0.0001 
##  soy        39.4 1.49 23     36.3     42.5   35  2.927  0.0076 
##  skim       44.8 1.79 23     41.1     48.5   35  5.486  &lt;.0001 
## 
## Results are averaged over the levels of: percent 
## Confidence level used: 0.95
</code></pre>

<p>These results all differ from either of the previous two summaries &ndash; again,
because the averaging is done on the <code>conc</code> scale rather than the <code>log(conc)</code> 
scale.</p>

<h6>{#regrid}</h6>

<!-- @index `regrid()`!`transform` vs. `type` -->

<p>Note: For those who want to routinely back-transform before averaging,
the <code>transform</code> argument in <code>ref_grid()</code> simplifies this. The first two
steps above could have been done more easily as follows:</p>

<pre><code class="r">pigs.remm.s &lt;- emmeans(pigs.lm, &quot;source&quot;, transform = &quot;response&quot;)
</code></pre>

<p>But don&#39;t get <code>transform</code> and <code>type</code> confused. The <code>transform</code> argument is 
passed to <code>regrid()</code> after the reference grid is constructed, whereas the <code>type</code>
argument is simply remembered and used by <code>summary()</code>. So a similar-looking
call:</p>

<pre><code class="r">emmeans(pigs.lm, &quot;source&quot;, type = &quot;response&quot;)
</code></pre>

<p>will compute the results we have seen for <code>pigs.emm.s</code> &ndash; back-transformed 
<em>after</em> averaging on the log scale.</p>

<p>Remember again: When it comes to transformations, timing is everything.</p>

<p><a href="#contents">Back to Contents</a></p>

<h2>Link functions {#links}</h2>

<!-- @index Link functions; Examples!`neuralgia`; Examples!Logistic regression -->

<p>Exactly the same ideas we have presented for response transformations apply to
generalized linear models having non-identity link functions. As far as
<strong>emmeans</strong> is concerned, there is no difference at all.</p>

<p>To illustrate, consider the <code>neuralgia</code> dataset provided in the package. These 
data come from an experiment reported in a SAS technical report where different
treatments for neuralgia are compared. The patient&#39;s sex is an additional
factor, and their age is a covariate. The response is <code>Pain</code>, a binary variable
on whether or not the patient reports neuralgia pain after treatment.
The model suggested in the SAS report is equivalent to the following. We use
it to obtain estimated probabilities of experiencing pain:</p>

<pre><code class="r">neuralgia.glm &lt;- glm(Pain ~ Treatment * Sex + Age, family = binomial(), data = neuralgia)
neuralgia.emm &lt;- emmeans(neuralgia.glm, &quot;Treatment&quot;, type = &quot;response&quot;)
</code></pre>

<pre><code>## NOTE: Results may be misleading due to involvement in interactions
</code></pre>

<pre><code class="r">neuralgia.emm
</code></pre>

<pre><code class="ro">##  Treatment  prob     SE  df asymp.LCL asymp.UCL
##  A         0.211 0.1109 Inf    0.0675     0.497
##  B         0.121 0.0835 Inf    0.0285     0.391
##  P         0.866 0.0883 Inf    0.5927     0.966
## 
## Results are averaged over the levels of: Sex 
## Confidence level used: 0.95 
## Intervals are back-transformed from the logit scale
</code></pre>

<h6>{#oddsrats}</h6>

<!-- @index Odds ratios; Logistic regression!Odds ratios -->

<p>(The note about the interaction is discussed shortly.) Note that the averaging 
over <code>Sex</code> is done on the logit scale, <em>before</em> the results are back-transformed
for the summary. We may use <code>pairs()</code> to compare these estimates; note that 
logits are logs of odds; so this is another instance where log-differences are
back-transformed &ndash; in this case to odds ratios:</p>

<pre><code class="r">pairs(neuralgia.emm, reverse = TRUE)
</code></pre>

<pre><code class="ro">##  contrast odds.ratio     SE  df z.ratio p.value
##  B / A         0.513  0.515 Inf -0.665  0.7837 
##  P / A        24.234 25.142 Inf  3.073  0.0060 
##  P / B        47.213 57.242 Inf  3.179  0.0042 
## 
## Results are averaged over the levels of: Sex 
## P value adjustment: tukey method for comparing a family of 3 estimates 
## Tests are performed on the log odds ratio scale
</code></pre>

<p>So there is evidence of considerably more pain being reported with placebo 
(treatment <code>P</code>) than with either of the other two treatments. The estimated odds
of pain with <code>B</code> are about half that for <code>A</code>, but this finding is not 
statistically significant. (The odds that this is a made-up dataset seem quite
high, but that finding is strictly this author&#39;s impression.)</p>

<p>Observe that there is a note in the output for <code>neuralgia.emm</code> that the results
may be misleading. It is important to take it seriously, because if two factors
interact, it may be the case that marginal averages of predictions don&#39;t reflect
what is happening at any level of the factors being averaged over. To find out,
look at an interaction plot of the fitted model:</p>

<pre><code class="r">emmip(neuralgia.glm, Sex ~ Treatment)
</code></pre>

<p><img src="data:image/png;base64,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" alt="plot of chunk unnamed-chunk-12"/></p>

<p>There is no practical difference between females and males in the patterns of
response to <code>Treatment</code>; so I think most people would be quite comfortable with
the marginal results that are reported earlier.</p>

<p><a href="#contents">Back to Contents</a></p>

<h2>Models having both a response transformation and a link function {#tranlink}</h2>

<!-- @index Transformations!with link function@link; Examples!`warpbreaks`
            Examples!Gamma regression; `summary()`!`type = "unlink"` -->

<p>It is possible to have a generalized linear model with a non-identity link <em>and</em> a response transformation. Here is an example, with the built-in <code>wapbreaks</code> dataset:</p>

<pre><code class="r">warp.glm &lt;- glm(sqrt(breaks) ~ wool*tension, family = Gamma, data = warpbreaks)
ref_grid(warp.glm)
</code></pre>

<pre><code class="ro">## &#39;emmGrid&#39; object with variables:
##     wool = A, B
##     tension = L, M, H
## Transformation: &quot;inverse&quot; 
## Additional response transformation: &quot;sqrt&quot;
</code></pre>

<p>The canonical link for a gamma model is the reciprocal (or inverse); and there is the square-root response transformation besides. If we choose <code>type = &quot;response&quot;</code>
in summarizing, we undo <em>both</em> transformations:</p>

<pre><code class="r">emmeans(warp.glm, ~ tension | wool, type = &quot;response&quot;)
</code></pre>

<pre><code class="ro">## wool = A:
##  tension response   SE  df asymp.LCL asymp.UCL
##  L           42.9 5.24 Inf      33.2      53.7
##  M           23.3 2.85 Inf      18.0      29.2
##  H           23.6 2.88 Inf      18.3      29.6
## 
## wool = B:
##  tension response   SE  df asymp.LCL asymp.UCL
##  L           27.4 3.35 Inf      21.3      34.4
##  M           28.1 3.43 Inf      21.8      35.2
##  H           18.5 2.26 Inf      14.3      23.2
## 
## Confidence level used: 0.95 
## Intervals are back-transformed from the sqrt scale
</code></pre>

<p>What happened here is first the linear predictor was back-transformed from the link scale (inverse); then the squares were obtained to back-transform the rest of the way. It is possible to undo the link, and not the response transformation:</p>

<pre><code class="r">emmeans(warp.glm, ~ tension | wool, type = &quot;unlink&quot;)
</code></pre>

<pre><code class="ro">## wool = A:
##  tension response    SE  df asymp.LCL asymp.UCL
##  L           6.55 0.400 Inf      5.85      7.44
##  M           4.83 0.295 Inf      4.31      5.48
##  H           4.86 0.297 Inf      4.34      5.52
## 
## wool = B:
##  tension response    SE  df asymp.LCL asymp.UCL
##  L           5.24 0.320 Inf      4.68      5.95
##  M           5.30 0.324 Inf      4.73      6.02
##  H           4.30 0.263 Inf      3.84      4.89
## 
## Confidence level used: 0.95 
## Intervals are back-transformed from the inverse scale
</code></pre>

<p>It is <em>not</em> possible to undo the response transformation and leave the link 
in place, because the response was transform first, then the link model was applied;
we have to undo those in reverse order to make sense.</p>

<p>One may also use <code>&quot;unlink&quot;</code> as a <code>transform</code> argument in <code>regrid()</code> or through
<code>ref_grid()</code>.</p>

<p><a href="#contents">Back to Contents</a></p>

<h2>Special transformations {#special}</h2>

<!-- @index Transformations!Custom; `make.tran()` -->

<p>The <code>make.tran()</code> function provides several special transformations and sets
things up so they can be handled in <strong>emmeans</strong> with relative ease. 
(See <code>help(&quot;make.tran&quot;, &quot;emmeans&quot;)</code> for descriptions
of what is available.) <code>make.tran()</code> works much like <code>stats::make.link()</code> in
that it returns a list of functions <code>linkfun()</code>, <code>linkinv()</code>, etc. that serve
in managing results on a transformed scale. The difference is that most 
transformations with <code>make.tran()</code> require additional arguments.</p>

<p>To use this capability in <code>emmeans()</code>, it is fortuitous to first obtain the 
<code>make.tran()</code> result, and then to use it as the enclosing environment
for fitting the model, with <code>linkfun</code> as the transformation. 
For example, suppose we want to use the response
transformation \(\log(y + \frac12)\). Then proceed like this:</p>

<pre><code class="r">tran &lt;- make.tran(&quot;genlog&quot;, 1/2)
my.model &lt;- with(tran, 
    lmer(linkfun(yield) ~ treatment + (1|Block), data = mydata))
</code></pre>

<p>Subsequent calls to <code>ref_grid()</code>, <code>emmeans()</code>, <code>regrid()</code>, etc. will then 
be able to access the transformation information correctly.</p>

<p>The help page for <code>make.tran()</code> has an example like this
using a Box-Cox transformation.</p>

<p><a href="#contents">Back to Contents</a></p>

<h2>Specifying a transformation after the fact {#after}</h2>

<!-- @index Transformations!Adding after the fact; `update()`!`tran` -->

<p>It is not at all uncommon to fit a model using statements like the following:</p>

<pre><code class="r">mydata &lt;- transform(mydata, logy.5 = log(yield + .5))
my.model &lt;- lmer(logy.5 ~ treatment + (1|Block), data = mydata)
</code></pre>

<p>In this case, there is no way for <code>ref_grid()</code> to figure out that a response
transformation was used. What can be done is to update the reference grid
with the required information:</p>

<pre><code class="r">my.rg &lt;- update(ref_grid(my.model), tran = make.tran(&quot;genlog&quot;, .5))
</code></pre>

<p>Subsequently, use <code>my.rg</code> in place of <code>my.mnodel</code> in any <code>emmeans()</code> analyses,
and the transformation information will be there.</p>

<p>For standard transformations (those in <code>stats::make.link()</code>), just give the name
of the transformation; e.g.,</p>

<pre><code class="r">model.rg &lt;- update(ref_grid(model), tran = &quot;sqrt&quot;)
</code></pre>

<p><a href="#contents">Back to Contents</a></p>

<h2>Faking a log transformation {#logs}</h2>

<!-- @index Transformations!Faking a log transformation; `regrid()`!`transform = "log"` -->

<p>The <code>regrid()</code> function makes it possible to fake a log transformation of the response. Why would you want to do this? So that you can make comparisons using
ratios instead of differences.</p>

<p>Consider the <code>pigs</code> example once again, but suppose we had fitted a model with a square-root transformation instead of a log:</p>

<pre><code class="r">pigroot.lm &lt;- lm(sqrt(conc) ~ source + factor(percent), data = pigs)
piglog.emm.s &lt;- regrid(emmeans(pigroot.lm, &quot;source&quot;), transform = &quot;log&quot;)
confint(piglog.emm.s, type = &quot;response&quot;)
</code></pre>

<pre><code class="ro">##  source response   SE df lower.CL upper.CL
##  fish       29.8 1.32 23     27.2     32.7
##  soy        39.2 1.54 23     36.2     42.6
##  skim       45.0 1.74 23     41.5     48.7
## 
## Results are averaged over the levels of: percent 
## Confidence level used: 0.95 
## Intervals are back-transformed from the log scale
</code></pre>

<pre><code class="r">pairs(piglog.emm.s, type = &quot;response&quot;)
</code></pre>

<pre><code class="ro">##  contrast    ratio     SE df t.ratio p.value
##  fish / soy  0.760 0.0454 23 -4.591  0.0004 
##  fish / skim 0.663 0.0391 23 -6.965  &lt;.0001 
##  soy / skim  0.872 0.0469 23 -2.548  0.0457 
## 
## Results are averaged over the levels of: percent 
## P value adjustment: tukey method for comparing a family of 3 estimates 
## Tests are performed on the log scale
</code></pre>

<p>These results are not identical, but very similar to the back-transformed
confidence intervals <a href="#timing">above</a> for the EMMs and the <a href="comparisons.html#logs">pairwise ratios in
the &ldquo;comparisons&rdquo; vignette</a>, where the fitted model
actually used a log response.</p>

<p><a href="#contents">Back to Contents</a></p>

<h2>Bias adjustment {#bias-adj}</h2>

<!-- @index Transformations!Bias adjustment; Bias adjustment!When back-transforming;
    Means!Generalized; Geometric means; -->

<p>So far, we have discussed ideas related to back-transforming results as a simple way
of expressing results on the same scale as the response. In particular, means
obtained in this way are known as <em>generalized means</em>; for example, a log
transformation of the response is associated with geometric means. When the goal
is simply to make inferences about which means are less than which other means,
and a response transformation is used, it is often acceptable to present
estimates and comparisons of these generalized means.
However, sometimes it is important to report results that actually do reflect
expected values of the untransformed response. An example is a financial study,
where the response is in some monetary unit. It may be convenient to use a
response transformation for modeling purposes, but ultimately we may want to
make financial projections in those same units. </p>

<p>In such settings, we need to
make a bias adjustment when we back-transform, because any nonlinear
transformation biases the expected values of statistical quantities. More
specifically, suppose that we have a response \(Y\) and the transformed
response is \(U\). To back-transform, we use \(Y = h(U)\); and using a Tayor
approximation, \(Y \approx h(\eta) + h'(\eta)(U-\eta) +
\frac12h'&lsquo;(\eta)(U-\eta)^2\), so that 
\(E(Y) \approx h(\eta) + \frac12h&rsquo;&lsquo;(\eta)Var(U)\). 
This shows that the amount of needed bias adjustment is approximately
\(\frac12h&rsquo;&lsquo;(\eta)\sigma^2\) where \(\sigma\) is the error SD in the model for \(U\).
It depends on \(\sigma\), and the larger this is, the greater the bias adjustment
is needed. This second-order bias adjustment is what is currently used
in the <strong>emmeans</strong> package when bias-adjustment is requested. There are better or exact adjustments for certain cases, and future updates may incorporate some of those.</p>

<h3>Response transformations vs. link functions {#link-bias}</h3>

<!-- @index Transformations!Response versus link functions;
    Bias adjustment!For link functions vs. response transformations; Bias adjustment!In GLMMs and GEE models; -->

<p>At this point, it is important to point out that the above discussion focuses on
response transformations, as opposed to link functions used in generalized linear
models (GLMs). In an ordinary GLM, no bias adjustment is needed or appropriate
because the link function is just used to define a nonlinear relationship
between the actual response mean \(\eta\) and the linear predictor. However, in a
generalized linear <em>mixed</em> model, including generalized estimating equations and
such, there are random components involved, and then bias adjustment becomes
appropriate.</p>

<h3>CBPP example {#cbpp}</h3>

<!-- @index Examples!`cbpp` -->

<p>Consider an example adapted from the help page for <code>lme4::cbpp</code>. 
Contagious bovine pleuropneumonia (CBPP) is a disease in African cattle,
and the dataset contains data on incidence of CBPP in several herds of cattle
over four time periods. We will fit a mixed model that accounts for herd variations
as well as overdispersion (variations larger than expected with a simple binomial model): </p>

<pre><code class="r">require(lme4)
cbpp &lt;- transform(cbpp, unit = 1:nrow(cbpp))
cbpp.glmer &lt;- glmer(cbind(incidence, size - incidence) ~ period + (1 | herd) +  (1|unit),
                    family = binomial, data = cbpp)

emm &lt;- emmeans(cbpp.glmer, &quot;period&quot;)
summary(emm, type = &quot;response&quot;)
</code></pre>

<pre><code class="ro">##  period   prob     SE  df asymp.LCL asymp.UCL
##  1      0.1824 0.0442 Inf    0.1109    0.2852
##  2      0.0614 0.0230 Inf    0.0290    0.1252
##  3      0.0558 0.0220 Inf    0.0254    0.1182
##  4      0.0334 0.0172 Inf    0.0120    0.0894
## 
## Confidence level used: 0.95 
## Intervals are back-transformed from the logit scale
</code></pre>

<p>The above summary reflects the back-transformed estimates, with no bias adjustment. However, the model estimates two independent sources of random variation that probably should be taken into account:</p>

<pre><code class="r">lme4::VarCorr(cbpp.glmer)
</code></pre>

<pre><code class="ro">##  Groups Name        Std.Dev.
##  unit   (Intercept) 0.89107 
##  herd   (Intercept) 0.18396
</code></pre>

<p>Notably, the over-dispersion SD is considerably greater than the herd SD.
Suppose we want to estimate the marginal probabilities of CBPP incidence,
averaged over herds and over-dispersion variations. For this purpose, we need
the combined effect of these variations; so we compute the overall SD
via the Pythagorean theorem:</p>

<pre><code class="r">total.SD = sqrt(0.89107^2 + 0.18396^2)
</code></pre>

<p>Accordingly, here are the bias-adjusted estimates of the marginal probabilities:</p>

<pre><code class="r">summary(emm, type = &quot;response&quot;, bias.adjust = TRUE, sigma = total.SD)
</code></pre>

<pre><code class="ro">##  period   prob     SE  df asymp.LCL asymp.UCL
##  1      0.2216 0.0462 Inf    0.1426     0.321
##  2      0.0823 0.0292 Inf    0.0400     0.159
##  3      0.0751 0.0282 Inf    0.0351     0.151
##  4      0.0458 0.0230 Inf    0.0168     0.117
## 
## Confidence level used: 0.95 
## Intervals are back-transformed from the logit scale 
## Bias adjustment applied based on sigma = 0.90986
</code></pre>

<p>These estimates are somewhat larger than the unadjusted estimates (actually, any estimates greater than 0.5 would have been adjusted downward). These adjusted estimates are more appropriate for describing the marginal incidence of CBPP for all herds. In fact, these estimates are fairly close to those obtained directly from the incidences in the data:</p>

<pre><code class="r">cases &lt;- with(cbpp, tapply(incidence, period, sum))
trials &lt;- with(cbpp, tapply(size, period, sum))
cases / trials
</code></pre>

<pre><code class="ro">##          1          2          3          4 
## 0.21942446 0.08018868 0.07106599 0.04516129
</code></pre>

<p><a href="#contents">Back to Contents</a></p>

<p><a href="vignette-topics.html">Index of all vignette topics</a> </p>

</body>

</html>
