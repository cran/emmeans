<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">

<head>

<meta charset="utf-8" />
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="pandoc" />

<meta name="viewport" content="width=device-width, initial-scale=1">

<meta name="author" content="Russ Lenth" />

<meta name="date" content="2018-05-20" />

<title>Confidence intervals and tests in emmeans</title>






<link href="data:text/css;charset=utf-8,body%20%7B%0Afont%2Dsize%3A%2011pt%3B%20font%2Dfamily%3A%20%22Palatino%20Linotype%22%2C%20%22Book%20Antiqua%22%2C%20Palatino%2C%20serif%3B%0Amargin%3A%2030px%2050px%2030px%2050px%3B%20%7D%0Ah1%2Ch2%2Ch3%2Ch4%2Ch5%2Ch6%20%7B%20font%2Dfamily%3A%20Arial%2CHelvetica%2CSans%2Dserif%3B%20%7D%0Aa%20%7B%20text%2Ddecoration%3A%20none%3B%20%7D%0Aa%3Alink%20%7B%20color%3Adarkblue%3B%20%7D%20a%3Avisited%20%7B%20color%3Adarkblue%3B%20%7D%20a%3Ahover%20%7B%20color%3Adodgerblue%3B%20%7D%0Aa%3Aactive%20%7B%20color%3Adodgerblue%3B%20%7D%20code%20%7B%0Acolor%3A%20%23602000%3B%0Afont%2Dfamily%3A%20%22Lucida%20Console%22%2C%20Monaco%2C%20monospace%3B%20font%2Dsize%3A%2090%25%3B%0A%7D%0A%2Er%20%7B%20%0Acolor%3A%20darkred%3B%20%7D%0A%2Ero%20%7B%20%0Acolor%3A%20darkgreen%3B%20background%2Dcolor%3A%20%23eeeeee%3B%20%7D%0A%2Er%20code%2C%20a%20code%2C%20%2Ero%20code%20%7B%20color%3A%20inherit%3B%20%7D%0A%2Evigindex%20ul%20%7B%20list%2Dstyle%2Dtype%3A%20none%3B%20%7D%0A%2Evigindex%20ul%20li%20%7B%20list%2Dstyle%3A%20none%3B%20%7D%0A%2Evigindex%20a%20code%20%7B%20color%3A%20inherit%3B%20%7D%0A%2Evigindex%20li%20code%20%7B%20color%3A%20inherit%3B%20%7D%0A" rel="stylesheet" type="text/css" />

</head>

<body>




<h1 class="title toc-ignore">Confidence intervals and tests in emmeans</h1>
<h4 class="author"><em>Russ Lenth</em></h4>
<h4 class="date"><em>2018-05-20</em></h4>



<!-- @index Vignettes!Confidence intervals and tests -->
<div id="contents" class="section level2">
<h2>Contents</h2>
<p>This vignette describes various ways of summarizing <code>emmGrid</code> objects.</p>
<ol style="list-style-type: decimal">
<li><a href="#emmobj"><code>emmGrid</code> objects, described</a></li>
<li><a href="#summary"><code>summary()</code>, <code>confint()</code>, and <code>test()</code></a></li>
<li><a href="#tran">Back-transforming to response scale</a> (See also the <a href="transformations.html">“transformations” vignette</a>)</li>
<li><a href="#adjust">Multiplicity adjustments</a></li>
<li><a href="#byvars">Using “by” variables</a></li>
<li><a href="#joint">Joint (omnibus) tests</a></li>
<li><a href="#equiv">Testing equivalence, noninferiority, nonsuperiority</a></li>
<li>Graphics (in <a href="basics.html#plots">“basics” vignette</a>)</li>
</ol>
<p><a href="vignette-topics.html">Index of all vignette topics</a></p>
</div>
<div id="emmobj" class="section level2">
<h2>Objects, structures, and methods</h2>
<!-- @index `emmGrid` objects -->
<p>The <code>ref_grid()</code> and <code>emmeans()</code> functions are introduced in <a href="basics.html">the “Basics” vignette</a>. These functions, and a few related ones, return an object of class <code>emmGrid</code>:</p>
<pre class="r"><code>pigs.lm &lt;- lm(log(conc) ~ source + factor(percent), data = pigs)
pigs.rg &lt;- ref_grid(pigs.lm)
class(pigs.rg)</code></pre>
<pre class="ro"><code>## [1] &quot;emmGrid&quot;
## attr(,&quot;package&quot;)
## [1] &quot;emmeans&quot;</code></pre>
<pre class="r"><code>pigs.emm.s &lt;- emmeans(pigs.rg, &quot;source&quot;)
class(pigs.emm.s)</code></pre>
<pre class="ro"><code>## [1] &quot;emmGrid&quot;
## attr(,&quot;package&quot;)
## [1] &quot;emmeans&quot;</code></pre>
<p>If you simply show these objects, you get different-looking results:</p>
<pre class="r"><code>pigs.rg</code></pre>
<pre class="ro"><code>## 'emmGrid' object with variables:
##     source = fish, soy, skim
##     percent =  9, 12, 15, 18
## Transformation: &quot;log&quot;</code></pre>
<pre class="r"><code>pigs.emm.s</code></pre>
<pre class="ro"><code>##  source   emmean         SE df lower.CL upper.CL
##  fish   3.394492 0.03668122 23 3.318612 3.470373
##  soy    3.667260 0.03744798 23 3.589793 3.744727
##  skim   3.796770 0.03938283 23 3.715300 3.878240
## 
## Results are averaged over the levels of: percent 
## Results are given on the log (not the response) scale. 
## Confidence level used: 0.95</code></pre>
<p>This is based on guessing what users most need to see when displaying the object. You can override these defaults; for example to just see a quick summary of what is there, do</p>
<pre class="r"><code>str(pigs.emm.s)</code></pre>
<pre class="ro"><code>## 'emmGrid' object with variables:
##     source = fish, soy, skim
## Transformation: &quot;log&quot;</code></pre>
<!-- @index `str()`; `summary_emm` object; `print.summary_emm()` -->
<p>The most important method for <code>emmGrid</code> objects is <code>summary()</code>. It is used as the default for displaying an <code>emmeans()</code> result like <code>pigs.emm.s</code>. This <code>summary()</code> method for <code>emmGrid</code> objects) actually produces a <code>data.frame</code>, but with extra bells and whistles:</p>
<pre class="r"><code>class(summary(pigs.emm.s))</code></pre>
<pre class="ro"><code>## [1] &quot;summary_emm&quot; &quot;data.frame&quot;</code></pre>
<p>This can be useful to know because if you want to actually <em>use</em> <code>emmeans()</code> results in other computations, you should save its summary, and then you can access those results just like you would access data in a data frame. The <code>emmGrid</code> object itself is not so accessible. There is a <code>print.summary_emm()</code> function that is what actually produces the output you see above – a data frame with extra annotations.</p>
<p><a href="#contents">Back to Contents</a></p>
</div>
<div id="summary" class="section level2">
<h2><code>summary()</code> and its relatives</h2>
<!-- @index `summary()`; `summary()`!`infer`; `confint()`; `test()`; Confidence intervals;
            Tests!One- and two-sided; Tests!Nonzero null -->
<p>As you may have gathered, the most important method for <code>emmGrid</code> objects is <code>summary()</code>. It has a lot of options, and the detailed documentation via <a href="../html/summary.emm.html"><code>help(&quot;summary.emm&quot;)</code></a> is worth a look.</p>
<p>Just <code>summary(&lt;object&gt;)</code> by itself will produce a summary that varies somewhat according to context. It does this by setting different defaults for the <code>infer</code> argument, which consists of two logical values, specifying confidence intervals and tests, respectively. The summary of a newly made reference grid will show just estimates and standard errors, but not confidence intervals or tests (that is, <code>infer = c(FALSE, FALSE)</code>). The summary of an <code>emmeans()</code> result, as we see above, will have intervals, but no tests (i.e., <code>infer = c(TRUE, FALSE)</code>); and the result of a <code>contrast()</code> call (see <a href="comparisons.html">comparisons and contrasts</a>) will show test statistics and <em>P</em> values, but not intervals (i.e., <code>infer = c(FALSE, TRUE)</code>). There are courtesy methods <code>confint()</code> and <code>test()</code> that just call <code>summary()</code> with the appropriate <code>infer</code> setting; for example,</p>
<pre class="r"><code>test(pigs.emm.s)</code></pre>
<pre class="ro"><code>##  source   emmean         SE df t.ratio p.value
##  fish   3.394492 0.03668122 23  92.540  &lt;.0001
##  soy    3.667260 0.03744798 23  97.929  &lt;.0001
##  skim   3.796770 0.03938283 23  96.407  &lt;.0001
## 
## Results are averaged over the levels of: percent 
## Results are given on the log (not the response) scale.</code></pre>
<p>It is not particularly useful, though, to test these EMMs against the default of zero – which is why tests are not usually shown. It makes a lot more sense to test them against some target concentration, say 40. And suppose we want to do a one-sided test to see if the concentration is greater than 40. Remembering that the response is log-transformed in this model,</p>
<pre class="r"><code>test(pigs.emm.s, null = log(40), side = &quot;&gt;&quot;)</code></pre>
<pre class="ro"><code>##  source   emmean         SE df     null t.ratio p.value
##  fish   3.394492 0.03668122 23 3.688879  -8.026  1.0000
##  soy    3.667260 0.03744798 23 3.688879  -0.577  0.7153
##  skim   3.796770 0.03938283 23 3.688879   2.740  0.0058
## 
## Results are averaged over the levels of: percent 
## Results are given on the log (not the response) scale. 
## P values are right-tailed</code></pre>
<p><a href="#contents">Back to Contents</a></p>
</div>
<div id="tran" class="section level2">
<h2>Back-transforming</h2>
<!-- @index Transformations!Back-transforming; `type`; Response scale -->
<p>Transformations and link functions are supported an several ways in <strong>emmeans</strong>, making this a complex topic worthy of <a href="transformations.html">its own vignette</a>. Here, we show just the most basic approach. Namely, specifying the argument <code>type = &quot;response&quot;</code> will cause the displayed results to be back-transformed to the response scale, when a transformation or link function is incorporated in the model. For example, let’s try the preceding <code>test()</code> call again:</p>
<pre class="r"><code>test(pigs.emm.s, null = log(40), side = &quot;&gt;&quot;, type = &quot;response&quot;)</code></pre>
<pre class="ro"><code>##  source response       SE df null t.ratio p.value
##  fish   29.79952 1.093083 23   40  -8.026  1.0000
##  soy    39.14451 1.465883 23   40  -0.577  0.7153
##  skim   44.55704 1.754782 23   40   2.740  0.0058
## 
## Results are averaged over the levels of: percent 
## P values are right-tailed 
## Tests are performed on the log scale</code></pre>
<p>Note what changes and what doesn’t change. In the <code>test()</code> call, we <em>still</em> use the log of 40 as the null value; <code>null</code> must always be specified on the linear-prediction scale, in this case the log. In the output, the displayed estimates, as well as the <code>null</code> value, are shown back-transformed. As well, the standard errors are altered (using the delta method). However, the <em>t</em> ratios and <em>P</em> values are identical to the preceding results. That is, the tests themselves are still conducted on the linear-predictor scale (as is noted in the output).</p>
<p>Similar statements apply to confidence intervals on the response scale:</p>
<pre class="r"><code>confint(pigs.emm.s, side = &quot;&gt;&quot;, level = .90, type = &quot;response&quot;)</code></pre>
<pre class="ro"><code>##  source response       SE df lower.CL upper.CL
##  fish   29.79952 1.093083 23 28.39159      Inf
##  soy    39.14451 1.465883 23 37.25735      Inf
##  skim   44.55704 1.754782 23 42.30080      Inf
## 
## Results are averaged over the levels of: percent 
## Confidence level used: 0.9 
## Intervals are back-transformed from the log scale</code></pre>
<p>With <code>side = &quot;&gt;&quot;</code>, a <em>lower</em> confidence limit is computed on the log scale, then that limit is back-transformed to the response scale. (We have also illustrated how to change the confidence level.)</p>
<p><a href="#contents">Back to Contents</a></p>
</div>
<div id="adjust" class="section level2">
<h2>Multiplicity adjustments</h2>
<!-- @index Multiplicity adjustments; `adjust`; 
     Tukey adjustment; Sidak adjustment -->
<p>Both tests and confidence intervals may be adjusted for simultaneous inference. Such adjustments ensure that the confidence coefficient for a whole set of intervals is at least the specified level, or to control the overall significance level for a whole family of tests. This is done via the <code>adjust</code> argument. For <code>ref_grid()</code> and <code>emmeans()</code> results, the default is <code>adjust = &quot;none&quot;</code>. For most <code>contrast()</code> results, <code>adjust</code> is often something else, depending on what type of contrasts are created. For example, pairwise comparisons default to <code>adjust = &quot;tukey&quot;</code>, i.e., the Tukey HSD method. The <code>summary()</code> function sometimes <em>changes</em> <code>adjust</code> if it is inappropriate. For example, with</p>
<pre class="r"><code>confint(pigs.emm.s, adjust = &quot;tukey&quot;)</code></pre>
<pre class="ro"><code>##  source   emmean         SE df lower.CL upper.CL
##  fish   3.394492 0.03668122 23 3.300060 3.488925
##  soy    3.667260 0.03744798 23 3.570854 3.763666
##  skim   3.796770 0.03938283 23 3.695383 3.898157
## 
## Results are averaged over the levels of: percent 
## Results are given on the log (not the response) scale. 
## Confidence level used: 0.95 
## Conf-level adjustment: sidak method for 3 estimates</code></pre>
<p>the adjustment is changed to the Sidak method because the Tukey adjustment is inappropriate unless you are doing pairwise comparisons.</p>
<div id="adjmore" class="section level7">
<p></p>
<!-- @index **mvtnorm** package; Bonferroni adjustment
     Multivariate *t* (`"mvt"`) adjustment; Unadjusted tests -->
<p>An adjustment method that is usually appropriate is Bonferroni; however, it can be quite conservative. Using <code>adjust = &quot;mvt&quot;</code> is the closest to being the “exact” all-around method “single-step” method, as it uses the multivariate <em>t</em> distribution (and the <strong>mvtnorm</strong> package) with the same covariance structure as the estimates to determine the adjustment. However, this comes at high computational expense as the computations are done using simulation techniques. For a large set of tests (and especially confidence intervals), the computational lag becomes noticeable if not intolerable.</p>
<p>For tests, <code>adjust</code> increases the <em>P</em> values over those otherwise obtained with <code>adjust = &quot;none&quot;</code>, making it harder to declare an individual test as “significant.” Compare the following adjusted tests with the unadjusted ones previously computed.</p>
<pre class="r"><code>test(pigs.emm.s, null = log(40), side = &quot;&gt;&quot;, adjust = &quot;bonferroni&quot;)</code></pre>
<pre class="ro"><code>##  source   emmean         SE df     null t.ratio p.value
##  fish   3.394492 0.03668122 23 3.688879  -8.026  1.0000
##  soy    3.667260 0.03744798 23 3.688879  -0.577  1.0000
##  skim   3.796770 0.03938283 23 3.688879   2.740  0.0175
## 
## Results are averaged over the levels of: percent 
## Results are given on the log (not the response) scale. 
## P value adjustment: bonferroni method for 3 tests 
## P values are right-tailed</code></pre>
<p><a href="#contents">Back to Contents</a></p>
</div>
</div>
<div id="byvars" class="section level2">
<h2>“By” variables</h2>
<!-- @index `by` groups; Grouping into separate sets -->
<p>Sometimes you want to break a summary down into smaller pieces; for this purpose, the <code>by</code> argument in <code>summary()</code> is useful. For example,</p>
<pre class="r"><code>confint(pigs.rg, by = &quot;source&quot;)</code></pre>
<pre class="ro"><code>## source = fish:
##  percent prediction         SE df lower.CL upper.CL
##        9   3.220292 0.05361160 23 3.109388 3.331196
##       12   3.399846 0.04934177 23 3.297775 3.501917
##       15   3.437691 0.05482126 23 3.324284 3.551097
##       18   3.520141 0.05474644 23 3.406889 3.633393
## 
## source = soy:
##  percent prediction         SE df lower.CL upper.CL
##        9   3.493060 0.04979018 23 3.390061 3.596058
##       12   3.672614 0.04893581 23 3.571383 3.773846
##       15   3.710459 0.05070383 23 3.605570 3.815347
##       18   3.792909 0.06398483 23 3.660546 3.925272
## 
## source = skim:
##  percent prediction         SE df lower.CL upper.CL
##        9   3.622569 0.05011840 23 3.518892 3.726247
##       12   3.802124 0.04938053 23 3.699972 3.904275
##       15   3.839968 0.05486610 23 3.726469 3.953468
##       18   3.922419 0.06459690 23 3.788790 4.056048
## 
## Results are given on the log (not the response) scale. 
## Confidence level used: 0.95</code></pre>
<p>If there is also an <code>adjust</code> in force when <code>by</code> variables are used, the adjustment is made <em>separately</em> on each <code>by</code> group; e.g., in the above, we would be adjusting for sets of 4 intervals, not all 12 together.</p>
<p>There can be a <code>by</code> specification in <code>emmeans()</code> (or equivalently, a <code>|</code> in the formula); and if so, it is passed on to <code>summary()</code> and used unless overridden by another <code>by</code>. Here are examples, not run:</p>
<pre class="r"><code>emmeans(pigs.lm, ~ percent | source)     ### same results as above
summary(.Last.value, by = percent)       ### grouped the other way</code></pre>
<p>Specifying <code>by = NULL</code> will remove all grouping.</p>
<div id="simple" class="section level3">
<h3>Simple comparisons</h3>
<!-- @index Simple comparisons; `contrast()`!`simple`; `simple = "each"` -->
<p>There is also a <code>simple</code> argument for <code>contrast()</code> that is in essence the inverse of <code>by</code>; the contrasts are run using everything <em>except</em> the specified variables as <code>by</code> variables. To illustrate, let’s consider the model for <code>pigs</code> that includes the interaction (so that the levels of one factor compare differently at levels of the other factor).</p>
<pre class="r"><code>pigsint.lm &lt;- lm(log(conc) ~ source * factor(percent), data = pigs)
pigsint.rg &lt;- ref_grid(pigsint.lm)
contrast(pigsint.rg, &quot;consec&quot;, simple = &quot;percent&quot;)</code></pre>
<pre class="ro"><code>## source = fish:
##  contrast     estimate         SE df t.ratio p.value
##  12 - 9    0.184851182 0.10612784 17   1.742  0.5274
##  15 - 12   0.004504448 0.10612784 17   0.042  1.0000
##  18 - 15   0.040679810 0.10612784 17   0.383  0.9999
## 
## source = soy:
##  contrast     estimate         SE df t.ratio p.value
##  12 - 9    0.141172845 0.09492363 17   1.487  0.6970
##  15 - 12  -0.010218130 0.09492363 17  -0.108  1.0000
##  18 - 15   0.089467012 0.13424228 17   0.666  0.9951
## 
## source = skim:
##  contrast     estimate         SE df t.ratio p.value
##  12 - 9    0.204318195 0.09492363 17   2.152  0.2922
##  15 - 12   0.139774084 0.10612784 17   1.317  0.8028
##  18 - 15   0.186377064 0.14238544 17   1.309  0.8074
## 
## Results are given on the log (not the response) scale. 
## P value adjustment: mvt method for 3 tests</code></pre>
<p>In fact, we may do <em>all</em> one-factor comparisons by specifying <code>simple = &quot;each&quot;</code>. This typically produces a lot of output, so use it with care.</p>
<p><a href="#contents">Back to Contents</a></p>
</div>
</div>
<div id="joint" class="section level2">
<h2>Joint tests</h2>
<!-- @index `test()`!`joint = TRUE`; `joint`; Type III tests -->
<p>From the above, we already know how to test individual results. For pairwise comparisons (details in <a href="comparisons.html">the “comparisons” vignette</a>), we might do</p>
<pre class="r"><code>pigs.prs.s &lt;- pairs(pigs.emm.s)
pigs.prs.s</code></pre>
<pre class="ro"><code>##  contrast      estimate         SE df t.ratio p.value
##  fish - soy  -0.2727678 0.05293450 23  -5.153  0.0001
##  fish - skim -0.4022777 0.05415929 23  -7.428  &lt;.0001
##  soy - skim  -0.1295098 0.05304280 23  -2.442  0.0570
## 
## Results are averaged over the levels of: percent 
## Results are given on the log (not the response) scale. 
## P value adjustment: tukey method for comparing a family of 3 estimates</code></pre>
<p>But suppose we want an <em>omnibus</em> test that all these comparisons are zero. Easy enough, using the <code>joint</code> argument in <code>test</code> (note: the <code>joint</code> argument is <em>not</em> available in <code>summary()</code>; only in <code>test()</code>):</p>
<pre class="r"><code>test(pigs.prs.s, joint = TRUE)</code></pre>
<pre class="ro"><code>##  df1 df2 F.ratio p.value note
##    2  23  28.849  &lt;.0001  d  
## 
## d: df1 reduced due to linear dependence</code></pre>
<p>Notice that there are three comparisons, but only 2 d.f. for the test, as cautioned in the message.</p>
<p>The test produced with <code>joint = TRUE</code> is a “type III” test (assuming the default equal weights are used to obtain the EMMs). See more on these types of tests for higher-order effects in the <a href="interactions.html#contrasts">“interactions” vignette section on contrasts</a>.</p>
<div id="joint_tests" class="section level7">
<p></p>
<!-- @index `joint_tests()`; Type III tests; Analysis of variance!Type III -->
<p>For convenience, there is also a <code>joint_tests()</code> function that performs joint tests of contrasts among each term in a model or <code>emmGrid</code> object.</p>
<pre class="r"><code>joint_tests(pigsint.rg)</code></pre>
<pre class="ro"><code>##  model term     df1 df2 F.ratio p.value
##  source           2  17  30.256  &lt;.0001
##  percent          3  17   8.214  0.0013
##  source:percent   6  17   0.926  0.5011</code></pre>
<p>The tests of main effects are of families of contrasts; those for interaction effects are for interaction contrasts. These results are essentially the same as a “Type-III ANOVA”, but may differ in situations where there are empty cells or other non-estimability issues, or if generalizations are present such as unequal weighting. (Another distinction is that sums of squares and mean squares are not shown; that is because these really are tests of contrasts among predictions, and they may or may not corresopond to model sums of squares.) One may use <code>by</code> variables to obtain separate tables of joint tests.</p>
<p><a href="#contents">Back to Contents</a></p>
</div>
</div>
<div id="equiv" class="section level2">
<h2>Testing equivalence, noninferiority, and nonsuperiority</h2>
<!-- @index Tests!Equivalence; Tests!Noninferiority; `test()`!`delta` -->
<p>The <code>delta</code> argument in <code>summary()</code> or <code>test()</code> allows the user to specify a threshold value to use in a test of equivalence, noninferiority, or nonsuperiority. An equivalence test is kind of a backwards significance test, where differences enough smaller than <code>delta</code> are the ones that can be significant. The help page for <code>summary.emmGrid</code> gives the details of these tests. Suppose in the present example, we consider two sources to be equivalent if they are within 25% of each other. We can test this as follows:</p>
<pre class="r"><code>test(pigs.prs.s, delta = log(1.25), adjust = &quot;none&quot;)</code></pre>
<pre class="ro"><code>##  contrast      estimate         SE df t.ratio p.value
##  fish - soy  -0.2727678 0.05293450 23   0.937  0.8209
##  fish - skim -0.4022777 0.05415929 23   3.308  0.9985
##  soy - skim  -0.1295098 0.05304280 23  -1.765  0.0454
## 
## Results are averaged over the levels of: percent 
## Results are given on the log (not the response) scale. 
## Statistics are tests of equivalence with a threshold of 0.22314 
## P values are left-tailed</code></pre>
<p>By our 25% standard, soy and skim are equivalent at the <span class="math inline">\(\alpha = .05\)</span> level, when no multiplicity adjustment is used.</p>
<p><a href="#contents">Back to Contents</a></p>
</div>
<div id="graphics" class="section level2">
<h2>Graphics</h2>
<p>Graphical displays of <code>emmGrid</code> objects are described in the <a href="basics.html#plots">“basics” vignette</a></p>
<p><a href="vignette-topics.html">Index of all vignette topics</a></p>
</div>



<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
