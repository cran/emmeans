<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>

<title>Contents {#contents}</title>

<script type="text/javascript">
window.onload = function() {
  var imgs = document.getElementsByTagName('img'), i, img;
  for (i = 0; i < imgs.length; i++) {
    img = imgs[i];
    // center an image if it is the only element of its parent
    if (img.parentElement.childElementCount === 1)
      img.parentElement.style.textAlign = 'center';
  }
};
</script>

<!-- Styles for R syntax highlighter -->
<style type="text/css">
   pre .operator,
   pre .paren {
     color: rgb(104, 118, 135)
   }

   pre .literal {
     color: #990073
   }

   pre .number {
     color: #099;
   }

   pre .comment {
     color: #998;
     font-style: italic
   }

   pre .keyword {
     color: #900;
     font-weight: bold
   }

   pre .identifier {
     color: rgb(0, 0, 0);
   }

   pre .string {
     color: #d14;
   }
</style>

<!-- R syntax highlighter -->
<script type="text/javascript">
var hljs=new function(){function m(p){return p.replace(/&/gm,"&amp;").replace(/</gm,"&lt;")}function f(r,q,p){return RegExp(q,"m"+(r.cI?"i":"")+(p?"g":""))}function b(r){for(var p=0;p<r.childNodes.length;p++){var q=r.childNodes[p];if(q.nodeName=="CODE"){return q}if(!(q.nodeType==3&&q.nodeValue.match(/\s+/))){break}}}function h(t,s){var p="";for(var r=0;r<t.childNodes.length;r++){if(t.childNodes[r].nodeType==3){var q=t.childNodes[r].nodeValue;if(s){q=q.replace(/\n/g,"")}p+=q}else{if(t.childNodes[r].nodeName=="BR"){p+="\n"}else{p+=h(t.childNodes[r])}}}if(/MSIE [678]/.test(navigator.userAgent)){p=p.replace(/\r/g,"\n")}return p}function a(s){var r=s.className.split(/\s+/);r=r.concat(s.parentNode.className.split(/\s+/));for(var q=0;q<r.length;q++){var p=r[q].replace(/^language-/,"");if(e[p]){return p}}}function c(q){var p=[];(function(s,t){for(var r=0;r<s.childNodes.length;r++){if(s.childNodes[r].nodeType==3){t+=s.childNodes[r].nodeValue.length}else{if(s.childNodes[r].nodeName=="BR"){t+=1}else{if(s.childNodes[r].nodeType==1){p.push({event:"start",offset:t,node:s.childNodes[r]});t=arguments.callee(s.childNodes[r],t);p.push({event:"stop",offset:t,node:s.childNodes[r]})}}}}return t})(q,0);return p}function k(y,w,x){var q=0;var z="";var s=[];function u(){if(y.length&&w.length){if(y[0].offset!=w[0].offset){return(y[0].offset<w[0].offset)?y:w}else{return w[0].event=="start"?y:w}}else{return y.length?y:w}}function t(D){var A="<"+D.nodeName.toLowerCase();for(var B=0;B<D.attributes.length;B++){var C=D.attributes[B];A+=" "+C.nodeName.toLowerCase();if(C.value!==undefined&&C.value!==false&&C.value!==null){A+='="'+m(C.value)+'"'}}return A+">"}while(y.length||w.length){var v=u().splice(0,1)[0];z+=m(x.substr(q,v.offset-q));q=v.offset;if(v.event=="start"){z+=t(v.node);s.push(v.node)}else{if(v.event=="stop"){var p,r=s.length;do{r--;p=s[r];z+=("</"+p.nodeName.toLowerCase()+">")}while(p!=v.node);s.splice(r,1);while(r<s.length){z+=t(s[r]);r++}}}}return z+m(x.substr(q))}function j(){function q(x,y,v){if(x.compiled){return}var u;var s=[];if(x.k){x.lR=f(y,x.l||hljs.IR,true);for(var w in x.k){if(!x.k.hasOwnProperty(w)){continue}if(x.k[w] instanceof Object){u=x.k[w]}else{u=x.k;w="keyword"}for(var r in u){if(!u.hasOwnProperty(r)){continue}x.k[r]=[w,u[r]];s.push(r)}}}if(!v){if(x.bWK){x.b="\\b("+s.join("|")+")\\s"}x.bR=f(y,x.b?x.b:"\\B|\\b");if(!x.e&&!x.eW){x.e="\\B|\\b"}if(x.e){x.eR=f(y,x.e)}}if(x.i){x.iR=f(y,x.i)}if(x.r===undefined){x.r=1}if(!x.c){x.c=[]}x.compiled=true;for(var t=0;t<x.c.length;t++){if(x.c[t]=="self"){x.c[t]=x}q(x.c[t],y,false)}if(x.starts){q(x.starts,y,false)}}for(var p in e){if(!e.hasOwnProperty(p)){continue}q(e[p].dM,e[p],true)}}function d(B,C){if(!j.called){j();j.called=true}function q(r,M){for(var L=0;L<M.c.length;L++){if((M.c[L].bR.exec(r)||[null])[0]==r){return M.c[L]}}}function v(L,r){if(D[L].e&&D[L].eR.test(r)){return 1}if(D[L].eW){var M=v(L-1,r);return M?M+1:0}return 0}function w(r,L){return L.i&&L.iR.test(r)}function K(N,O){var M=[];for(var L=0;L<N.c.length;L++){M.push(N.c[L].b)}var r=D.length-1;do{if(D[r].e){M.push(D[r].e)}r--}while(D[r+1].eW);if(N.i){M.push(N.i)}return f(O,M.join("|"),true)}function p(M,L){var N=D[D.length-1];if(!N.t){N.t=K(N,E)}N.t.lastIndex=L;var r=N.t.exec(M);return r?[M.substr(L,r.index-L),r[0],false]:[M.substr(L),"",true]}function z(N,r){var L=E.cI?r[0].toLowerCase():r[0];var M=N.k[L];if(M&&M instanceof Array){return M}return false}function F(L,P){L=m(L);if(!P.k){return L}var r="";var O=0;P.lR.lastIndex=0;var M=P.lR.exec(L);while(M){r+=L.substr(O,M.index-O);var N=z(P,M);if(N){x+=N[1];r+='<span class="'+N[0]+'">'+M[0]+"</span>"}else{r+=M[0]}O=P.lR.lastIndex;M=P.lR.exec(L)}return r+L.substr(O,L.length-O)}function J(L,M){if(M.sL&&e[M.sL]){var r=d(M.sL,L);x+=r.keyword_count;return r.value}else{return F(L,M)}}function I(M,r){var L=M.cN?'<span class="'+M.cN+'">':"";if(M.rB){y+=L;M.buffer=""}else{if(M.eB){y+=m(r)+L;M.buffer=""}else{y+=L;M.buffer=r}}D.push(M);A+=M.r}function G(N,M,Q){var R=D[D.length-1];if(Q){y+=J(R.buffer+N,R);return false}var P=q(M,R);if(P){y+=J(R.buffer+N,R);I(P,M);return P.rB}var L=v(D.length-1,M);if(L){var O=R.cN?"</span>":"";if(R.rE){y+=J(R.buffer+N,R)+O}else{if(R.eE){y+=J(R.buffer+N,R)+O+m(M)}else{y+=J(R.buffer+N+M,R)+O}}while(L>1){O=D[D.length-2].cN?"</span>":"";y+=O;L--;D.length--}var r=D[D.length-1];D.length--;D[D.length-1].buffer="";if(r.starts){I(r.starts,"")}return R.rE}if(w(M,R)){throw"Illegal"}}var E=e[B];var D=[E.dM];var A=0;var x=0;var y="";try{var s,u=0;E.dM.buffer="";do{s=p(C,u);var t=G(s[0],s[1],s[2]);u+=s[0].length;if(!t){u+=s[1].length}}while(!s[2]);if(D.length>1){throw"Illegal"}return{r:A,keyword_count:x,value:y}}catch(H){if(H=="Illegal"){return{r:0,keyword_count:0,value:m(C)}}else{throw H}}}function g(t){var p={keyword_count:0,r:0,value:m(t)};var r=p;for(var q in e){if(!e.hasOwnProperty(q)){continue}var s=d(q,t);s.language=q;if(s.keyword_count+s.r>r.keyword_count+r.r){r=s}if(s.keyword_count+s.r>p.keyword_count+p.r){r=p;p=s}}if(r.language){p.second_best=r}return p}function i(r,q,p){if(q){r=r.replace(/^((<[^>]+>|\t)+)/gm,function(t,w,v,u){return w.replace(/\t/g,q)})}if(p){r=r.replace(/\n/g,"<br>")}return r}function n(t,w,r){var x=h(t,r);var v=a(t);var y,s;if(v){y=d(v,x)}else{return}var q=c(t);if(q.length){s=document.createElement("pre");s.innerHTML=y.value;y.value=k(q,c(s),x)}y.value=i(y.value,w,r);var u=t.className;if(!u.match("(\\s|^)(language-)?"+v+"(\\s|$)")){u=u?(u+" "+v):v}if(/MSIE [678]/.test(navigator.userAgent)&&t.tagName=="CODE"&&t.parentNode.tagName=="PRE"){s=t.parentNode;var p=document.createElement("div");p.innerHTML="<pre><code>"+y.value+"</code></pre>";t=p.firstChild.firstChild;p.firstChild.cN=s.cN;s.parentNode.replaceChild(p.firstChild,s)}else{t.innerHTML=y.value}t.className=u;t.result={language:v,kw:y.keyword_count,re:y.r};if(y.second_best){t.second_best={language:y.second_best.language,kw:y.second_best.keyword_count,re:y.second_best.r}}}function o(){if(o.called){return}o.called=true;var r=document.getElementsByTagName("pre");for(var p=0;p<r.length;p++){var q=b(r[p]);if(q){n(q,hljs.tabReplace)}}}function l(){if(window.addEventListener){window.addEventListener("DOMContentLoaded",o,false);window.addEventListener("load",o,false)}else{if(window.attachEvent){window.attachEvent("onload",o)}else{window.onload=o}}}var e={};this.LANGUAGES=e;this.highlight=d;this.highlightAuto=g;this.fixMarkup=i;this.highlightBlock=n;this.initHighlighting=o;this.initHighlightingOnLoad=l;this.IR="[a-zA-Z][a-zA-Z0-9_]*";this.UIR="[a-zA-Z_][a-zA-Z0-9_]*";this.NR="\\b\\d+(\\.\\d+)?";this.CNR="\\b(0[xX][a-fA-F0-9]+|(\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)";this.BNR="\\b(0b[01]+)";this.RSR="!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|\\.|-|-=|/|/=|:|;|<|<<|<<=|<=|=|==|===|>|>=|>>|>>=|>>>|>>>=|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~";this.ER="(?![\\s\\S])";this.BE={b:"\\\\.",r:0};this.ASM={cN:"string",b:"'",e:"'",i:"\\n",c:[this.BE],r:0};this.QSM={cN:"string",b:'"',e:'"',i:"\\n",c:[this.BE],r:0};this.CLCM={cN:"comment",b:"//",e:"$"};this.CBLCLM={cN:"comment",b:"/\\*",e:"\\*/"};this.HCM={cN:"comment",b:"#",e:"$"};this.NM={cN:"number",b:this.NR,r:0};this.CNM={cN:"number",b:this.CNR,r:0};this.BNM={cN:"number",b:this.BNR,r:0};this.inherit=function(r,s){var p={};for(var q in r){p[q]=r[q]}if(s){for(var q in s){p[q]=s[q]}}return p}}();hljs.LANGUAGES.cpp=function(){var a={keyword:{"false":1,"int":1,"float":1,"while":1,"private":1,"char":1,"catch":1,"export":1,virtual:1,operator:2,sizeof:2,dynamic_cast:2,typedef:2,const_cast:2,"const":1,struct:1,"for":1,static_cast:2,union:1,namespace:1,unsigned:1,"long":1,"throw":1,"volatile":2,"static":1,"protected":1,bool:1,template:1,mutable:1,"if":1,"public":1,friend:2,"do":1,"return":1,"goto":1,auto:1,"void":2,"enum":1,"else":1,"break":1,"new":1,extern:1,using:1,"true":1,"class":1,asm:1,"case":1,typeid:1,"short":1,reinterpret_cast:2,"default":1,"double":1,register:1,explicit:1,signed:1,typename:1,"try":1,"this":1,"switch":1,"continue":1,wchar_t:1,inline:1,"delete":1,alignof:1,char16_t:1,char32_t:1,constexpr:1,decltype:1,noexcept:1,nullptr:1,static_assert:1,thread_local:1,restrict:1,_Bool:1,complex:1},built_in:{std:1,string:1,cin:1,cout:1,cerr:1,clog:1,stringstream:1,istringstream:1,ostringstream:1,auto_ptr:1,deque:1,list:1,queue:1,stack:1,vector:1,map:1,set:1,bitset:1,multiset:1,multimap:1,unordered_set:1,unordered_map:1,unordered_multiset:1,unordered_multimap:1,array:1,shared_ptr:1}};return{dM:{k:a,i:"</",c:[hljs.CLCM,hljs.CBLCLM,hljs.QSM,{cN:"string",b:"'\\\\?.",e:"'",i:"."},{cN:"number",b:"\\b(\\d+(\\.\\d*)?|\\.\\d+)(u|U|l|L|ul|UL|f|F)"},hljs.CNM,{cN:"preprocessor",b:"#",e:"$"},{cN:"stl_container",b:"\\b(deque|list|queue|stack|vector|map|set|bitset|multiset|multimap|unordered_map|unordered_set|unordered_multiset|unordered_multimap|array)\\s*<",e:">",k:a,r:10,c:["self"]}]}}}();hljs.LANGUAGES.r={dM:{c:[hljs.HCM,{cN:"number",b:"\\b0[xX][0-9a-fA-F]+[Li]?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+(?:[eE][+\\-]?\\d*)?L\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+\\.(?!\\d)(?:i\\b)?",e:hljs.IMMEDIATE_RE,r:1},{cN:"number",b:"\\b\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\.\\d+(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"keyword",b:"(?:tryCatch|library|setGeneric|setGroupGeneric)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\.",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\d+(?![\\w.])",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\b(?:function)",e:hljs.IMMEDIATE_RE,r:2},{cN:"keyword",b:"(?:if|in|break|next|repeat|else|for|return|switch|while|try|stop|warning|require|attach|detach|source|setMethod|setClass)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"literal",b:"(?:NA|NA_integer_|NA_real_|NA_character_|NA_complex_)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"literal",b:"(?:NULL|TRUE|FALSE|T|F|Inf|NaN)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"identifier",b:"[a-zA-Z.][a-zA-Z0-9._]*\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"<\\-(?!\\s*\\d)",e:hljs.IMMEDIATE_RE,r:2},{cN:"operator",b:"\\->|<\\-",e:hljs.IMMEDIATE_RE,r:1},{cN:"operator",b:"%%|~",e:hljs.IMMEDIATE_RE},{cN:"operator",b:">=|<=|==|!=|\\|\\||&&|=|\\+|\\-|\\*|/|\\^|>|<|!|&|\\||\\$|:",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"%",e:"%",i:"\\n",r:1},{cN:"identifier",b:"`",e:"`",r:0},{cN:"string",b:'"',e:'"',c:[hljs.BE],r:0},{cN:"string",b:"'",e:"'",c:[hljs.BE],r:0},{cN:"paren",b:"[[({\\])}]",e:hljs.IMMEDIATE_RE,r:0}]}};
hljs.initHighlightingOnLoad();
</script>



<style type="text/css">
body, td {
   font-family: sans-serif;
   background-color: white;
   font-size: 13px;
}

body {
  max-width: 800px;
  margin: auto;
  padding: 1em;
  line-height: 20px;
}

tt, code, pre {
   font-family: 'DejaVu Sans Mono', 'Droid Sans Mono', 'Lucida Console', Consolas, Monaco, monospace;
}

h1 {
   font-size:2.2em;
}

h2 {
   font-size:1.8em;
}

h3 {
   font-size:1.4em;
}

h4 {
   font-size:1.0em;
}

h5 {
   font-size:0.9em;
}

h6 {
   font-size:0.8em;
}

a:visited {
   color: rgb(50%, 0%, 50%);
}

pre, img {
  max-width: 100%;
}
pre {
  overflow-x: auto;
}
pre code {
   display: block; padding: 0.5em;
}

code {
  font-size: 92%;
  border: 1px solid #ccc;
}

code[class] {
  background-color: #F8F8F8;
}

table, td, th {
  border: none;
}

blockquote {
   color:#666666;
   margin:0;
   padding-left: 1em;
   border-left: 0.5em #EEE solid;
}

hr {
   height: 0px;
   border-bottom: none;
   border-top-width: thin;
   border-top-style: dotted;
   border-top-color: #999999;
}

@media print {
   * {
      background: transparent !important;
      color: black !important;
      filter:none !important;
      -ms-filter: none !important;
   }

   body {
      font-size:12pt;
      max-width:100%;
   }

   a, a:visited {
      text-decoration: underline;
   }

   hr {
      visibility: hidden;
      page-break-before: always;
   }

   pre, blockquote {
      padding-right: 1em;
      page-break-inside: avoid;
   }

   tr, img {
      page-break-inside: avoid;
   }

   img {
      max-width: 100% !important;
   }

   @page :left {
      margin: 15mm 20mm 15mm 10mm;
   }

   @page :right {
      margin: 15mm 10mm 15mm 20mm;
   }

   p, h2, h3 {
      orphans: 3; widows: 3;
   }

   h2, h3 {
      page-break-after: avoid;
   }
}
</style>



</head>

<body>
<!-- @index Vignettes!Messy data -->

<h2>Contents {#contents}</h2>

<ol>
<li><a href="#issues">Issues with observational data</a> </li>
<li><a href="#mediators">Mediating covariates</a> </li>
<li><a href="#weights">Mediating factors and weights</a> </li>
<li><a href="#nesting">Nested fixed effects</a>
 a. <a href="#nest-trap">Avoiding mis-identified nesting</a></li>
</ol>

<p><a href="vignette-topics.html">Index of all vignette topics</a></p>

<h2>Issues with observational data {#issues}</h2>

<!-- @index Observational data -->

<p>In experiments, we control the
conditions under which observations are made. Ideally, this leads to balanced
datasets and clear inferences about the effects of those experimental
conditions. In observational data, factor levels are observed rather than
controlled, and in the analysis we control <em>for</em> those factors and covariates.
It is possible that some factors and covariates lie in the causal path for other
predictors. Observational studies can be designed in ways to mitigate some of
these issues; but often we are left with a mess. Using EMMs does not solve the
inherent problems in messy, undesigned studies; but they do give us ways to
compensate for imbalance in the data, and allow us to estimate meaningful
effects after carefully considering the ways in which they can be confounded.</p>

<p>####### {#nutrex}</p>

<!-- @index Examples!`nutrition` -->

<p>As an illustration, consider the <code>nutrition</code> dataset provided with the package. 
These data are used as an example in Milliken and Johnson (1992), <em>Analysis of 
Messy Data</em>, and contain the results of an observational study on nutrition 
education. Low-income mothers are classified by race, age category, and whether 
or not they received food stamps (the <code>group</code> factor); and the response variable
is a gain score (post minus pre scores) after completing a nutrition training 
program. First, let&#39;s fit a model than includes all main effects and 2-way 
interactions, and obtain its &ldquo;type II&rdquo; ANOVA:</p>

<pre><code class="r">nutr.lm &lt;- lm(gain ~ (age + group + race)^2, data = nutrition) 
car::Anova(nutr.lm)
</code></pre>

<pre><code>## Note: model has aliased coefficients
##       sums of squares computed by model comparison
</code></pre>

<pre><code class="ro">## Anova Table (Type II tests)
## 
## Response: gain
##             Sum Sq Df F value    Pr(&gt;F)
## age          82.37  3  0.9614    0.4145
## group       658.13  1 23.0441 6.105e-06
## race         11.17  2  0.1956    0.8227
## age:group    91.58  3  1.0688    0.3663
## age:race     87.30  3  1.0189    0.3880
## group:race  113.70  2  1.9906    0.1424
## Residuals  2627.47 92
</code></pre>

<p>There is definitely a
<code>group</code> effect and a hint of and interaction with <code>race</code>. Here are the EMMs for
those two factors:</p>

<pre><code class="r">emmeans(nutr.lm, ~ group * race)
</code></pre>

<pre><code class="ro">##  group      race     emmean   SE df lower.CL upper.CL
##  FoodStamps Black      4.71 2.37 92  0.00497     9.41
##  NoAid      Black     -2.19 2.49 92 -7.13690     2.76
##  FoodStamps Hispanic nonEst   NA NA       NA       NA
##  NoAid      Hispanic nonEst   NA NA       NA       NA
##  FoodStamps White      3.61 1.16 92  1.31252     5.90
##  NoAid      White      2.26 2.39 92 -2.48897     7.00
## 
## Results are averaged over the levels of: age 
## Confidence level used: 0.95
</code></pre>

<p>####### {#nonestex}</p>

<!-- @index Non-estimability; Estimability -->

<p>Hmmmm. The EMMs
when <code>race</code> is &ldquo;Hispanic&rdquo; are not given; instead they are flagged as 
non-estimable. What does that mean? Well, when using a model to make
predictions, it is impossible to do that beyond the linear space of the data
used to fit the model. And we have no data for three of the age groups in the
Hispanic population:</p>

<pre><code class="r">with(nutrition, table(race, age))
</code></pre>

<pre><code class="ro">##           age
## race        1  2  3  4
##   Black     2  7 10  2
##   Hispanic  0  0  3  0
##   White     5 16 51 11
</code></pre>

<p>We can&#39;t make
predictions for all the cases we are averaging over in the above EMMs, and that
is why some of them are non-estimable. The bottom line is that we simply cannot
include Hispanics in the mix when comparing factor effects. That&#39;s a limitation
of this study that cannot be overcome without collecting additional data. Our
choices for further analysis are to focus only on Black and White populations;
or to focus only on age group 3. For example (the latter):</p>

<pre><code class="r">summary(emmeans(nutr.lm, pairwise ~ group | race, at = list(age = &quot;3&quot;)), 
    by = NULL)
</code></pre>

<pre><code class="ro">## $emmeans
##  group      race     emmean   SE df lower.CL upper.CL
##  FoodStamps Black      7.50 2.67 92     2.19   12.807
##  NoAid      Black     -3.67 2.18 92    -8.00    0.666
##  FoodStamps Hispanic   0.00 5.34 92   -10.61   10.614
##  NoAid      Hispanic   2.50 3.78 92    -5.01   10.005
##  FoodStamps White      5.42 0.96 92     3.51    7.326
##  NoAid      White     -0.20 1.19 92    -2.57    2.173
## 
## Confidence level used: 0.95 
## 
## $contrasts
##  contrast           race     estimate   SE df t.ratio p.value
##  FoodStamps - NoAid Black       11.17 3.45 92  3.237  0.0017 
##  FoodStamps - NoAid Hispanic    -2.50 6.55 92 -0.382  0.7034 
##  FoodStamps - NoAid White        5.62 1.53 92  3.666  0.0004
</code></pre>

<p>(We used trickery with providing a <code>by</code> variable, and then taking it
away, to make the output more compact.) Evidently, the training program has been
beneficial to the Black and White groups in that age category. There is no 
conclusion for the Hispanic group &ndash; for which we have very little data.</p>

<p><a href="#contents">Back to Contents</a></p>

<h2>Mediating covariates {#mediators}</h2>

<!-- @index Mediating covariates; Examples!`framing`; Covariates!Mediating -->

<p>The <code>framing</code> data in the <strong>mediation</strong>
package has the results of an experiment conducted by Brader et al. (2008) where
subjects were given the opportunity to send a message to Congress regarding
immigration. However, before being offered this, some subjects (<code>treat = 1</code>)
were first shown a news story that portrays Latinos in a negative way. Besides
the binary response (whether or not they elected to send a message), the
experimenters also measured <code>emo</code>, the subjects&#39; emotional state after the
treatment was applied. There are various demographic variables as well. Let&#39;s a
logistic regression model, after changing the labels for <code>educ</code> to shorter
strings. </p>

<pre><code class="r">framing &lt;- mediation::framing 
</code></pre>

<pre><code>## Registered S3 methods overwritten by &#39;lme4&#39;:
##   method                          from
##   cooks.distance.influence.merMod car 
##   influence.merMod                car 
##   dfbeta.influence.merMod         car 
##   dfbetas.influence.merMod        car
</code></pre>

<pre><code class="r">levels(framing$educ) &lt;- c(&quot;NA&quot;,&quot;Ref&quot;,&quot;&lt; HS&quot;, &quot;HS&quot;, &quot;&gt; HS&quot;,&quot;Coll +&quot;) 
framing.glm &lt;- glm(cong_mesg ~ age + income + educ + emo + gender * factor(treat), 
    family = binomial, data = framing)
</code></pre>

<p>The conventional way to handle covariates like <code>emo</code> is to set them at their
means and use those means for purposes of predictions and EMMs. These adjusted 
means are shown in the following plot. </p>

<pre><code class="r">emmip(framing.glm, treat ~ educ | gender, type = &quot;response&quot;) 
</code></pre>

<p><img src="data:image/png;base64,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" alt="plot of chunk unnamed-chunk-7"/></p>

<p>This plot gives the impression that the effect of <code>treat</code> is reversed between 
male and female subjects; and also that the effect of education is not monotone.
Both of these are counter-intuitive.</p>

<h6>{#med.covred}</h6>

<!-- @index `cov.reduce` -->

<p>However, note that the covariate <code>emo</code> is measured <em>post</em>-treatment. That 
suggests that in fact <code>treat</code> (and perhaps other factors) could affect the value
of <code>emo</code>; and if that is true (as is in fact established by mediation analysis 
techniques), we should not pretend that <code>emo</code> can be set independently of 
<code>treat</code> as was done to obtain the EMMs shown above. Instead, let <code>emo</code> depend on
<code>treat</code> and the other predictors &ndash; easily done using <code>cov.reduce</code> &ndash; and we 
obtain an entirely different impression:</p>

<pre><code class="r">emmip(framing.glm, treat ~ educ | gender, type = &quot;response&quot;, 
    cov.reduce = emo ~ treat*gender + age + educ + income)
</code></pre>

<p><img src="data:image/png;base64,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" alt="plot of chunk unnamed-chunk-8"/></p>

<p>The reference grid underlying this plot has different <code>emo</code> values for each 
factor combination. The plot suggests that, after taking emotional response into
account, male (but not female) subjects exposed to the negative news story are 
more likely to send the message than are females or those not seeing the 
negative news story. Also, the effect of <code>educ</code> is now nearly monotone.</p>

<h6>{#adjcov}</h6>

<!-- @index Covariates!Adjusted -->

<p>By the way, the results in this plot are the same is what you would obtain by
refitting the model with an adjusted covariate</p>

<pre><code class="r">emo.adj &lt;- resid(lm(emo ~ treat*gender + age + educ + income, data = framing))
</code></pre>

<p>&hellip; and then using ordinary covariate-adjusted means at the means of <code>emo.adj</code>. 
This is a technique that is often recommended.</p>

<p>If there is more than one mediating covariate, their settings may be defined in
sequence; for example, if <code>x1</code>, <code>x2</code>, and <code>x3</code> are all mediating covariates, we
might use</p>

<pre><code class="r">emmeans(..., cov.reduce = list(x1 ~ trt, x2 ~ trt + x1, x3 ~ trt + x1 + x2))
</code></pre>

<p>(or possibly with some interactions included as well).</p>

<p><a href="#contents">Back to Contents</a></p>

<h2>Mediating factors and weights {#weights}</h2>

<!-- @index Factors!Mediating; `weights`; `emmeans()`!`weights` -->

<p>A mediating covariate is one that is
in the causal path; likewise, it is possible to have a mediating <em>factor</em>. For
mediating factors, the moral equivalent of the <code>cov.reduce</code> technique described
above is to use <em>weighted</em> averages in lieu of equally-weighted ones in
computing EMMs. The weights used in these averages should depend on the
frequencies of mediating factor(s). Usually, the <code>&quot;cells&quot;</code> weighting scheme
described later in this section is the right approach. In complex situations, it
may be necessary to compute EMMs in stages.</p>

<p>As described in <a href="basics.html#emmeans">the &ldquo;basics&rdquo; vignette</a>, EMMs are usually 
defined as <em>equally-weighted</em> means of reference-grid predictions. However, 
there are several built-in alternative weighting schemes that are available by 
specifying a character value for <code>weights</code> in a call to <code>emmeans()</code> or related 
function. The options are <code>&quot;equal&quot;</code> (the default), <code>&quot;proportional&quot;</code>, <code>&quot;outer&quot;</code>,
<code>&quot;cells&quot;</code>, and <code>&quot;flat&quot;</code>.</p>

<p>The <code>&quot;proportional&quot;</code> (or <code>&quot;prop&quot;</code> for short) method weights proportionally to
the frequencies (or model weights) of each factor combination that is averaged
over. The <code>&quot;outer&quot;</code> method uses the outer product of the marginal frequencies of
each factor that is being averaged over. To explain the distinction, suppose the
EMMs for <code>A</code> involve averaging over two factors <code>B</code> and <code>C</code>. With <code>&quot;prop&quot;</code>, we
use the frequencies for each combination of <code>B</code> and <code>C</code>; whereas for <code>&quot;outer&quot;</code>,
first obtain the marginal frequencies for <code>B</code> and for <code>C</code> and weight
proportionally to the product of these for each combination of <code>B</code> and <code>C</code>. The
latter weights are like the &ldquo;expected&rdquo; counts used in a chi-square test for
independence. Put another way, outer weighting is the same as proportional
weighting applied one factor at a time; the following two would yield the same
results: </p>

<pre><code class="r">emmeans(model, &quot;A&quot;, weights = &quot;outer&quot;) 
emmeans(emmeans(model, c(&quot;A&quot;, &quot;B&quot;), weights = &quot;prop&quot;),  weights = &quot;prop&quot;) 
</code></pre>

<p>Using <code>&quot;cells&quot;</code> weights gives each prediction the same weight as occurs in the
model; applied to a reference grid for a model with all interactions,
<code>&quot;cells&quot;</code>-weighted EMMs are the same as the ordinary marginal means of the data.
With <code>&quot;flat&quot;</code> weights, equal weights are used, except zero weight is applied to
any factor combination having no data. Usually, <code>&quot;cells&quot;</code> or <code>&quot;flat&quot;</code> weighting
will <em>not</em> produce non-estimable results, because we exclude empty cells. (That
said, if covariates are linearly dependent with factors, we may still encounter
non-estimable cases.)</p>

<p>Here is a comparison of predictions for <code>nutr.lm</code> defined <a href="#issues">above</a>,
using different weighting schemes:</p>

<pre><code class="r">sapply(c(&quot;equal&quot;, &quot;prop&quot;, &quot;outer&quot;, &quot;cells&quot;, &quot;flat&quot;), function(w)
    predict(emmeans(nutr.lm, ~ race, weights = w)))
</code></pre>

<pre><code class="ro">##         equal     prop    outer     cells      flat
## [1,] 1.258929 1.926554 2.546674 0.3809524 0.6865079
## [2,]       NA       NA       NA 1.6666667 1.2500000
## [3,] 2.932008 2.522821 3.142940 2.7951807 1.6103407
</code></pre>

<p>For <code>group * race</code> EMMs, the results for <code>&quot;prop&quot;</code> and <code>&quot;flat&quot;</code> are the same
because only one factor (<code>age</code>) is averaged over.</p>

<p><a href="#contents">Back to Contents</a></p>

<h2>Nested fixed effects {#nesting}</h2>

<!-- @index Nesting -->

<p>A factor <code>A</code> is nested in another factor <code>B</code> if the levels of <code>A</code> have a
different meaning in one level of <code>B</code> than in another. Often, nested factors are
random effects&mdash;for example, subjects in an experiment may be randomly assigned
to treatments, in which case subjects are nested in treatments&mdash;and if we model
them as random effects, these random nested effects are not among the fixed
effects and are not an issue to <code>emmeans</code>. But sometimes we have fixed nested
factors.</p>

<h6>{#cows}</h6>

<!-- @index Examples!`cows`; Examples!Nested fixed effects -->

<p>Here is an example of a fictional study of five fictional treatments for some
disease in cows. Two of the treatments are administered by injection, and the
other three are administered orally. There are varying numbers of observations
for each drug. The data and model follow:</p>

<pre><code class="r">cows &lt;- data.frame (
    route = factor(rep(c(&quot;injection&quot;, &quot;oral&quot;), c(5, 9))),
    drug = factor(rep(c(&quot;Bovineumab&quot;, &quot;Charloisazepam&quot;, 
              &quot;Angustatin&quot;, &quot;Herefordmycin&quot;, &quot;Mollycoddle&quot;), c(3,2,  4,2,3))),
    resp = c(34, 35, 34,   44, 43,      36, 33, 36, 32,   26, 25,   25, 24, 24)
)
cows.lm &lt;- lm(resp ~ route + drug, data = cows)
</code></pre>

<p>The <code>ref_grid</code> function finds a nested structure in this model:</p>

<pre><code class="r">cows.rg &lt;- ref_grid(cows.lm)
cows.rg
</code></pre>

<pre><code class="ro">## &#39;emmGrid&#39; object with variables:
##     route = injection, oral
##     drug = Angustatin, Bovineumab, Charloisazepam, Herefordmycin, Mollycoddle
## Nesting structure:  drug %in% route
</code></pre>

<p>When there is nesting, <code>emmeans</code> computes averages separately in each group\ldots</p>

<pre><code class="r">route.emm &lt;- emmeans(cows.rg, &quot;route&quot;)
route.emm
</code></pre>

<pre><code class="ro">##  route     emmean    SE df lower.CL upper.CL
##  injection   38.9 0.591  9     37.6     40.3
##  oral        28.0 0.449  9     27.0     29.0
## 
## Results are averaged over the levels of: drug 
## Confidence level used: 0.95
</code></pre>

<p>&hellip; and insists on carrying along any grouping factors that a factor is nested in:</p>

<pre><code class="r">drug.emm &lt;- emmeans(cows.rg, &quot;drug&quot;)
drug.emm
</code></pre>

<pre><code class="ro">##  drug           route     emmean    SE df lower.CL upper.CL
##  Bovineumab     injection   34.3 0.747  9     32.6     36.0
##  Charloisazepam injection   43.5 0.915  9     41.4     45.6
##  Angustatin     oral        34.2 0.647  9     32.8     35.7
##  Herefordmycin  oral        25.5 0.915  9     23.4     27.6
##  Mollycoddle    oral        24.3 0.747  9     22.6     26.0
## 
## Confidence level used: 0.95
</code></pre>

<p>Here are the associated pairwise comparisons:</p>

<pre><code class="r">pairs(route.emm, reverse = TRUE)
</code></pre>

<pre><code class="ro">##  contrast         estimate    SE df t.ratio p.value
##  oral - injection    -10.9 0.742  9 -14.671 &lt;.0001 
## 
## Results are averaged over the levels of: drug
</code></pre>

<pre><code class="r">pairs(drug.emm, by = &quot;route&quot;, reverse = TRUE)
</code></pre>

<pre><code class="ro">## route = injection:
##  contrast                    estimate    SE df t.ratio p.value
##  Charloisazepam - Bovineumab     9.17 1.182  9   7.757 &lt;.0001 
## 
## route = oral:
##  contrast                    estimate    SE df t.ratio p.value
##  Herefordmycin - Angustatin     -8.75 1.121  9  -7.805 0.0001 
##  Mollycoddle - Angustatin       -9.92 0.989  9 -10.030 &lt;.0001 
##  Mollycoddle - Herefordmycin    -1.17 1.182  9  -0.987 0.6026 
## 
## P value adjustment: tukey method for comparing a family of 3 estimates
</code></pre>

<p>In the latter result, the contrast itself becomes a nested factor in the
returned <code>emmGrid</code> object. That would not be the case if there had been no <code>by</code>
variable.</p>

<h3>Auto-identification of nested factors &ndash; avoid being trapped! {#nest-trap}</h3>

<!-- @index Nesting!Auto-detection; `ref_grid()`!`nesting` -->

<p><code>ref_grid()</code> and <code>emmeans()</code> tries to discover
and accommodate nested structures in the fixed effects. It does this in two
ways: first, by identifying factors whose levels appear in combination with only
one level of another factor; and second, by examining the <code>terms</code> attribute of
the fixed effects. In the latter approach, if an interaction <code>A:B</code> appears
in the model but <code>A</code> is not present as a main effect, then <code>A</code> is deemed to
be nested in <code>B</code>. Note that this can create a trap: some users take shortcuts
by omitting some fixed effects, knowing that this won&#39;t affect the fitted
values. But such shortcuts <em>do</em> affect the interpretation of model parameters,
ANOVA tables, etc., and I advise against ever taking such shortcuts. 
Here are some ways you may notice mistakenly-identified nesting:</p>

<ul>
<li>A message is displayed when nesting is detected</li>
<li>A <code>str()</code> listing of the <code>emmGrid</code> object shows a nesting component</li>
<li>An <code>emmeans()</code> summary unexpectedly includes one or more factors
that you didn&#39;t specify</li>
<li>EMMs obtained using <code>by</code> factors don&#39;t seem to behave right, or
give the same results with different specifications</li>
</ul>

<p>To override the auto-detection of nested effects, use the <code>nesting</code> argument
in <code>ref_grid()</code> or <code>emmeans()</code>. Specifying <code>nesting = NULL</code> will ignore
all nesting. Incorrectly-discovered nesting can be overcome by specifying 
something akin to <code>nesting = &quot;A %in% B, C %in% (A * B)&quot;</code> or, equivalently,
<code>nesting = list(A = &quot;B&quot;,  C = c(&quot;A&quot;, &quot;B&quot;))</code>.</p>

<p><a href="#contents">Back to Contents</a></p>

<p><a href="vignette-topics.html">Index of all vignette topics</a></p>

</body>

</html>
