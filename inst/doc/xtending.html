<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>

<title>Contents {#contents}</title>

<script type="text/javascript">
window.onload = function() {
  var imgs = document.getElementsByTagName('img'), i, img;
  for (i = 0; i < imgs.length; i++) {
    img = imgs[i];
    // center an image if it is the only element of its parent
    if (img.parentElement.childElementCount === 1)
      img.parentElement.style.textAlign = 'center';
  }
};
</script>

<!-- Styles for R syntax highlighter -->
<style type="text/css">
   pre .operator,
   pre .paren {
     color: rgb(104, 118, 135)
   }

   pre .literal {
     color: #990073
   }

   pre .number {
     color: #099;
   }

   pre .comment {
     color: #998;
     font-style: italic
   }

   pre .keyword {
     color: #900;
     font-weight: bold
   }

   pre .identifier {
     color: rgb(0, 0, 0);
   }

   pre .string {
     color: #d14;
   }
</style>

<!-- R syntax highlighter -->
<script type="text/javascript">
var hljs=new function(){function m(p){return p.replace(/&/gm,"&amp;").replace(/</gm,"&lt;")}function f(r,q,p){return RegExp(q,"m"+(r.cI?"i":"")+(p?"g":""))}function b(r){for(var p=0;p<r.childNodes.length;p++){var q=r.childNodes[p];if(q.nodeName=="CODE"){return q}if(!(q.nodeType==3&&q.nodeValue.match(/\s+/))){break}}}function h(t,s){var p="";for(var r=0;r<t.childNodes.length;r++){if(t.childNodes[r].nodeType==3){var q=t.childNodes[r].nodeValue;if(s){q=q.replace(/\n/g,"")}p+=q}else{if(t.childNodes[r].nodeName=="BR"){p+="\n"}else{p+=h(t.childNodes[r])}}}if(/MSIE [678]/.test(navigator.userAgent)){p=p.replace(/\r/g,"\n")}return p}function a(s){var r=s.className.split(/\s+/);r=r.concat(s.parentNode.className.split(/\s+/));for(var q=0;q<r.length;q++){var p=r[q].replace(/^language-/,"");if(e[p]){return p}}}function c(q){var p=[];(function(s,t){for(var r=0;r<s.childNodes.length;r++){if(s.childNodes[r].nodeType==3){t+=s.childNodes[r].nodeValue.length}else{if(s.childNodes[r].nodeName=="BR"){t+=1}else{if(s.childNodes[r].nodeType==1){p.push({event:"start",offset:t,node:s.childNodes[r]});t=arguments.callee(s.childNodes[r],t);p.push({event:"stop",offset:t,node:s.childNodes[r]})}}}}return t})(q,0);return p}function k(y,w,x){var q=0;var z="";var s=[];function u(){if(y.length&&w.length){if(y[0].offset!=w[0].offset){return(y[0].offset<w[0].offset)?y:w}else{return w[0].event=="start"?y:w}}else{return y.length?y:w}}function t(D){var A="<"+D.nodeName.toLowerCase();for(var B=0;B<D.attributes.length;B++){var C=D.attributes[B];A+=" "+C.nodeName.toLowerCase();if(C.value!==undefined&&C.value!==false&&C.value!==null){A+='="'+m(C.value)+'"'}}return A+">"}while(y.length||w.length){var v=u().splice(0,1)[0];z+=m(x.substr(q,v.offset-q));q=v.offset;if(v.event=="start"){z+=t(v.node);s.push(v.node)}else{if(v.event=="stop"){var p,r=s.length;do{r--;p=s[r];z+=("</"+p.nodeName.toLowerCase()+">")}while(p!=v.node);s.splice(r,1);while(r<s.length){z+=t(s[r]);r++}}}}return z+m(x.substr(q))}function j(){function q(x,y,v){if(x.compiled){return}var u;var s=[];if(x.k){x.lR=f(y,x.l||hljs.IR,true);for(var w in x.k){if(!x.k.hasOwnProperty(w)){continue}if(x.k[w] instanceof Object){u=x.k[w]}else{u=x.k;w="keyword"}for(var r in u){if(!u.hasOwnProperty(r)){continue}x.k[r]=[w,u[r]];s.push(r)}}}if(!v){if(x.bWK){x.b="\\b("+s.join("|")+")\\s"}x.bR=f(y,x.b?x.b:"\\B|\\b");if(!x.e&&!x.eW){x.e="\\B|\\b"}if(x.e){x.eR=f(y,x.e)}}if(x.i){x.iR=f(y,x.i)}if(x.r===undefined){x.r=1}if(!x.c){x.c=[]}x.compiled=true;for(var t=0;t<x.c.length;t++){if(x.c[t]=="self"){x.c[t]=x}q(x.c[t],y,false)}if(x.starts){q(x.starts,y,false)}}for(var p in e){if(!e.hasOwnProperty(p)){continue}q(e[p].dM,e[p],true)}}function d(B,C){if(!j.called){j();j.called=true}function q(r,M){for(var L=0;L<M.c.length;L++){if((M.c[L].bR.exec(r)||[null])[0]==r){return M.c[L]}}}function v(L,r){if(D[L].e&&D[L].eR.test(r)){return 1}if(D[L].eW){var M=v(L-1,r);return M?M+1:0}return 0}function w(r,L){return L.i&&L.iR.test(r)}function K(N,O){var M=[];for(var L=0;L<N.c.length;L++){M.push(N.c[L].b)}var r=D.length-1;do{if(D[r].e){M.push(D[r].e)}r--}while(D[r+1].eW);if(N.i){M.push(N.i)}return f(O,M.join("|"),true)}function p(M,L){var N=D[D.length-1];if(!N.t){N.t=K(N,E)}N.t.lastIndex=L;var r=N.t.exec(M);return r?[M.substr(L,r.index-L),r[0],false]:[M.substr(L),"",true]}function z(N,r){var L=E.cI?r[0].toLowerCase():r[0];var M=N.k[L];if(M&&M instanceof Array){return M}return false}function F(L,P){L=m(L);if(!P.k){return L}var r="";var O=0;P.lR.lastIndex=0;var M=P.lR.exec(L);while(M){r+=L.substr(O,M.index-O);var N=z(P,M);if(N){x+=N[1];r+='<span class="'+N[0]+'">'+M[0]+"</span>"}else{r+=M[0]}O=P.lR.lastIndex;M=P.lR.exec(L)}return r+L.substr(O,L.length-O)}function J(L,M){if(M.sL&&e[M.sL]){var r=d(M.sL,L);x+=r.keyword_count;return r.value}else{return F(L,M)}}function I(M,r){var L=M.cN?'<span class="'+M.cN+'">':"";if(M.rB){y+=L;M.buffer=""}else{if(M.eB){y+=m(r)+L;M.buffer=""}else{y+=L;M.buffer=r}}D.push(M);A+=M.r}function G(N,M,Q){var R=D[D.length-1];if(Q){y+=J(R.buffer+N,R);return false}var P=q(M,R);if(P){y+=J(R.buffer+N,R);I(P,M);return P.rB}var L=v(D.length-1,M);if(L){var O=R.cN?"</span>":"";if(R.rE){y+=J(R.buffer+N,R)+O}else{if(R.eE){y+=J(R.buffer+N,R)+O+m(M)}else{y+=J(R.buffer+N+M,R)+O}}while(L>1){O=D[D.length-2].cN?"</span>":"";y+=O;L--;D.length--}var r=D[D.length-1];D.length--;D[D.length-1].buffer="";if(r.starts){I(r.starts,"")}return R.rE}if(w(M,R)){throw"Illegal"}}var E=e[B];var D=[E.dM];var A=0;var x=0;var y="";try{var s,u=0;E.dM.buffer="";do{s=p(C,u);var t=G(s[0],s[1],s[2]);u+=s[0].length;if(!t){u+=s[1].length}}while(!s[2]);if(D.length>1){throw"Illegal"}return{r:A,keyword_count:x,value:y}}catch(H){if(H=="Illegal"){return{r:0,keyword_count:0,value:m(C)}}else{throw H}}}function g(t){var p={keyword_count:0,r:0,value:m(t)};var r=p;for(var q in e){if(!e.hasOwnProperty(q)){continue}var s=d(q,t);s.language=q;if(s.keyword_count+s.r>r.keyword_count+r.r){r=s}if(s.keyword_count+s.r>p.keyword_count+p.r){r=p;p=s}}if(r.language){p.second_best=r}return p}function i(r,q,p){if(q){r=r.replace(/^((<[^>]+>|\t)+)/gm,function(t,w,v,u){return w.replace(/\t/g,q)})}if(p){r=r.replace(/\n/g,"<br>")}return r}function n(t,w,r){var x=h(t,r);var v=a(t);var y,s;if(v){y=d(v,x)}else{return}var q=c(t);if(q.length){s=document.createElement("pre");s.innerHTML=y.value;y.value=k(q,c(s),x)}y.value=i(y.value,w,r);var u=t.className;if(!u.match("(\\s|^)(language-)?"+v+"(\\s|$)")){u=u?(u+" "+v):v}if(/MSIE [678]/.test(navigator.userAgent)&&t.tagName=="CODE"&&t.parentNode.tagName=="PRE"){s=t.parentNode;var p=document.createElement("div");p.innerHTML="<pre><code>"+y.value+"</code></pre>";t=p.firstChild.firstChild;p.firstChild.cN=s.cN;s.parentNode.replaceChild(p.firstChild,s)}else{t.innerHTML=y.value}t.className=u;t.result={language:v,kw:y.keyword_count,re:y.r};if(y.second_best){t.second_best={language:y.second_best.language,kw:y.second_best.keyword_count,re:y.second_best.r}}}function o(){if(o.called){return}o.called=true;var r=document.getElementsByTagName("pre");for(var p=0;p<r.length;p++){var q=b(r[p]);if(q){n(q,hljs.tabReplace)}}}function l(){if(window.addEventListener){window.addEventListener("DOMContentLoaded",o,false);window.addEventListener("load",o,false)}else{if(window.attachEvent){window.attachEvent("onload",o)}else{window.onload=o}}}var e={};this.LANGUAGES=e;this.highlight=d;this.highlightAuto=g;this.fixMarkup=i;this.highlightBlock=n;this.initHighlighting=o;this.initHighlightingOnLoad=l;this.IR="[a-zA-Z][a-zA-Z0-9_]*";this.UIR="[a-zA-Z_][a-zA-Z0-9_]*";this.NR="\\b\\d+(\\.\\d+)?";this.CNR="\\b(0[xX][a-fA-F0-9]+|(\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)";this.BNR="\\b(0b[01]+)";this.RSR="!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|\\.|-|-=|/|/=|:|;|<|<<|<<=|<=|=|==|===|>|>=|>>|>>=|>>>|>>>=|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~";this.ER="(?![\\s\\S])";this.BE={b:"\\\\.",r:0};this.ASM={cN:"string",b:"'",e:"'",i:"\\n",c:[this.BE],r:0};this.QSM={cN:"string",b:'"',e:'"',i:"\\n",c:[this.BE],r:0};this.CLCM={cN:"comment",b:"//",e:"$"};this.CBLCLM={cN:"comment",b:"/\\*",e:"\\*/"};this.HCM={cN:"comment",b:"#",e:"$"};this.NM={cN:"number",b:this.NR,r:0};this.CNM={cN:"number",b:this.CNR,r:0};this.BNM={cN:"number",b:this.BNR,r:0};this.inherit=function(r,s){var p={};for(var q in r){p[q]=r[q]}if(s){for(var q in s){p[q]=s[q]}}return p}}();hljs.LANGUAGES.cpp=function(){var a={keyword:{"false":1,"int":1,"float":1,"while":1,"private":1,"char":1,"catch":1,"export":1,virtual:1,operator:2,sizeof:2,dynamic_cast:2,typedef:2,const_cast:2,"const":1,struct:1,"for":1,static_cast:2,union:1,namespace:1,unsigned:1,"long":1,"throw":1,"volatile":2,"static":1,"protected":1,bool:1,template:1,mutable:1,"if":1,"public":1,friend:2,"do":1,"return":1,"goto":1,auto:1,"void":2,"enum":1,"else":1,"break":1,"new":1,extern:1,using:1,"true":1,"class":1,asm:1,"case":1,typeid:1,"short":1,reinterpret_cast:2,"default":1,"double":1,register:1,explicit:1,signed:1,typename:1,"try":1,"this":1,"switch":1,"continue":1,wchar_t:1,inline:1,"delete":1,alignof:1,char16_t:1,char32_t:1,constexpr:1,decltype:1,noexcept:1,nullptr:1,static_assert:1,thread_local:1,restrict:1,_Bool:1,complex:1},built_in:{std:1,string:1,cin:1,cout:1,cerr:1,clog:1,stringstream:1,istringstream:1,ostringstream:1,auto_ptr:1,deque:1,list:1,queue:1,stack:1,vector:1,map:1,set:1,bitset:1,multiset:1,multimap:1,unordered_set:1,unordered_map:1,unordered_multiset:1,unordered_multimap:1,array:1,shared_ptr:1}};return{dM:{k:a,i:"</",c:[hljs.CLCM,hljs.CBLCLM,hljs.QSM,{cN:"string",b:"'\\\\?.",e:"'",i:"."},{cN:"number",b:"\\b(\\d+(\\.\\d*)?|\\.\\d+)(u|U|l|L|ul|UL|f|F)"},hljs.CNM,{cN:"preprocessor",b:"#",e:"$"},{cN:"stl_container",b:"\\b(deque|list|queue|stack|vector|map|set|bitset|multiset|multimap|unordered_map|unordered_set|unordered_multiset|unordered_multimap|array)\\s*<",e:">",k:a,r:10,c:["self"]}]}}}();hljs.LANGUAGES.r={dM:{c:[hljs.HCM,{cN:"number",b:"\\b0[xX][0-9a-fA-F]+[Li]?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+(?:[eE][+\\-]?\\d*)?L\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+\\.(?!\\d)(?:i\\b)?",e:hljs.IMMEDIATE_RE,r:1},{cN:"number",b:"\\b\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\.\\d+(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"keyword",b:"(?:tryCatch|library|setGeneric|setGroupGeneric)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\.",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\d+(?![\\w.])",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\b(?:function)",e:hljs.IMMEDIATE_RE,r:2},{cN:"keyword",b:"(?:if|in|break|next|repeat|else|for|return|switch|while|try|stop|warning|require|attach|detach|source|setMethod|setClass)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"literal",b:"(?:NA|NA_integer_|NA_real_|NA_character_|NA_complex_)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"literal",b:"(?:NULL|TRUE|FALSE|T|F|Inf|NaN)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"identifier",b:"[a-zA-Z.][a-zA-Z0-9._]*\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"<\\-(?!\\s*\\d)",e:hljs.IMMEDIATE_RE,r:2},{cN:"operator",b:"\\->|<\\-",e:hljs.IMMEDIATE_RE,r:1},{cN:"operator",b:"%%|~",e:hljs.IMMEDIATE_RE},{cN:"operator",b:">=|<=|==|!=|\\|\\||&&|=|\\+|\\-|\\*|/|\\^|>|<|!|&|\\||\\$|:",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"%",e:"%",i:"\\n",r:1},{cN:"identifier",b:"`",e:"`",r:0},{cN:"string",b:'"',e:'"',c:[hljs.BE],r:0},{cN:"string",b:"'",e:"'",c:[hljs.BE],r:0},{cN:"paren",b:"[[({\\])}]",e:hljs.IMMEDIATE_RE,r:0}]}};
hljs.initHighlightingOnLoad();
</script>



<style type="text/css">
body, td {
   font-family: sans-serif;
   background-color: white;
   font-size: 13px;
}

body {
  max-width: 800px;
  margin: auto;
  padding: 1em;
  line-height: 20px;
}

tt, code, pre {
   font-family: 'DejaVu Sans Mono', 'Droid Sans Mono', 'Lucida Console', Consolas, Monaco, monospace;
}

h1 {
   font-size:2.2em;
}

h2 {
   font-size:1.8em;
}

h3 {
   font-size:1.4em;
}

h4 {
   font-size:1.0em;
}

h5 {
   font-size:0.9em;
}

h6 {
   font-size:0.8em;
}

a:visited {
   color: rgb(50%, 0%, 50%);
}

pre, img {
  max-width: 100%;
}
pre {
  overflow-x: auto;
}
pre code {
   display: block; padding: 0.5em;
}

code {
  font-size: 92%;
  border: 1px solid #ccc;
}

code[class] {
  background-color: #F8F8F8;
}

table, td, th {
  border: none;
}

blockquote {
   color:#666666;
   margin:0;
   padding-left: 1em;
   border-left: 0.5em #EEE solid;
}

hr {
   height: 0px;
   border-bottom: none;
   border-top-width: thin;
   border-top-style: dotted;
   border-top-color: #999999;
}

@media print {
   * {
      background: transparent !important;
      color: black !important;
      filter:none !important;
      -ms-filter: none !important;
   }

   body {
      font-size:12pt;
      max-width:100%;
   }

   a, a:visited {
      text-decoration: underline;
   }

   hr {
      visibility: hidden;
      page-break-before: always;
   }

   pre, blockquote {
      padding-right: 1em;
      page-break-inside: avoid;
   }

   tr, img {
      page-break-inside: avoid;
   }

   img {
      max-width: 100% !important;
   }

   @page :left {
      margin: 15mm 20mm 15mm 10mm;
   }

   @page :right {
      margin: 15mm 10mm 15mm 20mm;
   }

   p, h2, h3 {
      orphans: 3; widows: 3;
   }

   h2, h3 {
      page-break-after: avoid;
   }
}
</style>



</head>

<body>
<!-- @index Vignettes!Extending **emmeans** -->

<h2>Contents {#contents}</h2>

<p>This vignette explains how developers may incorporate <strong>emmeans</strong> support in their packages.</p>

<ol>
<li><a href="#intro">Introduction</a></li>
<li><a href="#dataex">Data example</a></li>
<li><a href="#rlm">Supporting <code>rlm</code> objects</a></li>
<li><a href="#lqs">Supporting <code>lqs</code> objects</a></li>
<li><a href="#communic">Communication between methods</a></li>
<li><a href="#hooks">Hook functions</a></li>
<li><a href="#exported">Exported methods from <strong>emmeans</strong></a></li>
<li><a href="#rsm">Existing support for <code>rsm</code> objects</a></li>
<li><a href="#exporting">Exporting and registering your methods</a></li>
<li><a href="#concl">Conclusions</a></li>
</ol>

<p><a href="vignette-topics.html">Index of all vignette topics</a></p>

<h2>Introduction {#intro}</h2>

<!-- @index `recover_data()`; `emm_basis()` -->

<p>Suppose you want to use <strong>emmeans</strong> for some type of model that it doesn&#39;t (yet) support. Or, suppose you have developed a new package with a fancy model-fitting function, and you&#39;d like it to work with <strong>emmeans</strong>. What can you do? Well, there is hope because <strong>emmeans</strong> is designed to be extended. </p>

<p>The first thing to do is to look at the help page for extending the package:</p>

<pre><code class="r">help(&quot;extending-emmeans&quot;, package=&quot;emmeans&quot;)
</code></pre>

<p>It gives details about the fact that you need to write two S3 methods, <code>recover_data</code> and <code>emm_basis</code>, for the class of object that your model-fitting function returns. The <code>recover_data</code>  method is needed to recreate the dataset so that the reference grid can be identified. The <code>emm_basis</code> method then determines the linear functions needed to evaluate each point in the reference grid and to obtain associated information&mdash;such as the variance-covariance matrix&mdash;needed to do estimation and testing.</p>

<p>These methods must also be exported from your package so that they are available
to users. See the section on <a href="#exporting">exporting the methods</a> for details and
suggestions.</p>

<p>This vignette presents an example where suitable methods are developed, and discusses a few issues that arise.</p>

<p><a href="#contents">Back to Contents</a></p>

<h2>Data example {#dataex}</h2>

<p>The <strong>MASS</strong> package contains various functions that do robust or outlier-resistant model fitting. We will cobble together some <strong>emmeans</strong> support for these. But first, let&#39;s create a suitable dataset (a simulated two-factor experiment) for testing.</p>

<pre><code class="r">fake = expand.grid(rep = 1:5, A = c(&quot;a1&quot;,&quot;a2&quot;), B = c(&quot;b1&quot;,&quot;b2&quot;,&quot;b3&quot;))
fake$y = c(11.46,12.93,11.87,11.01,11.92,17.80,13.41,13.96,14.27,15.82,
           23.14,23.75,-2.09,28.43,23.01,24.11,25.51,24.11,23.95,30.37,
           17.75,18.28,17.82,18.52,16.33,20.58,20.55,20.77,21.21,20.10)
</code></pre>

<p>The <code>y</code> values were generated using predetermined means and Cauchy-distributed errors. There are some serious outliers in these data.</p>

<h2>Supporting <code>rlm</code> {#rlm}</h2>

<!-- @index Examples!Robust regression; Examples!`rlm` objects -->

<p>The <strong>MASS</strong> package provides an <code>rlm</code> function that fits robust-regression models using <em>M</em> estimation. We&#39;ll fit a model using the default settings for all tuning parameters:</p>

<pre><code class="r">library(MASS)
fake.rlm = rlm(y ~ A * B, data = fake)

library(emmeans)
emmeans(fake.rlm, ~ B | A)
</code></pre>

<pre><code class="ro">## A = a1:
##  B  emmean    SE df asymp.LCL asymp.UCL
##  b1   11.8 0.477 NA      10.9      12.8
##  b2   23.3 0.477 NA      22.4      24.2
##  b3   17.8 0.477 NA      16.9      18.7
## 
## A = a2:
##  B  emmean    SE df asymp.LCL asymp.UCL
##  b1   14.7 0.477 NA      13.7      15.6
##  b2   24.7 0.477 NA      23.8      25.6
##  b3   20.6 0.477 NA      19.7      21.6
## 
## Confidence level used: 0.95
</code></pre>

<p>The first lesson to learn about extending <strong>emmeans</strong> is that sometimes, it already works! It works here because <code>rlm</code> objects inherit from <code>lm</code>, which is supported by the <strong>emmeans</strong> package, and <code>rlm</code> objects aren&#39;t enough different to create any problems.</p>

<p><a href="#contents">Back to Contents</a></p>

<h2>Supporting <code>lqs</code> objects {#lqs}</h2>

<!-- @index Examples!`lqs` objects -->

<p>The <strong>MASS</strong> resistant-regression functions <code>lqs</code>, <code>lmsreg</code>, and <code>ltsreg</code> are another story, however. They create <code>lqs</code> objects that are not extensions of any other class, and have other issues, including not even having a <code>vcov</code> method. So for these, we really do need to write new methods for <code>lqs</code> objects. First, let&#39;s fit a model.</p>

<pre><code class="r">fake.lts = ltsreg(y ~ A * B, data = fake)
</code></pre>

<h3>The <code>recover_data</code> method {#rd.lqs}</h3>

<!-- @index `recover_data()!for `lqs` objects@lqs -->

<p>It is usually an easy matter to write a <code>recover_data</code> method. Look at the one for <code>lm</code> objects:</p>

<pre><code class="r">emmeans:::recover_data.lm
</code></pre>

<pre><code class="ro">## function (object, ...) 
## {
##     fcall = object$call
##     recover_data(fcall, delete.response(terms(object)), object$na.action, 
##         ...)
## }
## &lt;bytecode: 0x000000001e8c63e8&gt;
## &lt;environment: namespace:emmeans&gt;
</code></pre>

<p>Note that all it does is obtain the <code>call</code> component and call the method for class <code>call</code>, with additional arguments for its <code>terms</code> component and <code>na.action</code>. It happens that we can access these attributes in exactly the same way as for <code>lm</code> objects; so:</p>

<pre><code class="r">recover_data.lqs = emmeans:::recover_data.lm
</code></pre>

<p>Let&#39;s test it:</p>

<pre><code class="r">rec.fake = recover_data(fake.lts)
head(rec.fake)
</code></pre>

<pre><code class="ro">##    A  B
## 1 a1 b1
## 2 a1 b1
## 3 a1 b1
## 4 a1 b1
## 5 a1 b1
## 6 a2 b1
</code></pre>

<p>Our recovered data excludes the response variable <code>y</code> (owing to the <code>delete.response</code> call), and this is fine. </p>

<h4>Special arguments {#rdargs}</h4>

<!-- @index `recover_data()!`data` and `params` arguments -->

<p>By the way, there are two special arguments <code>data</code> and <code>params</code> that may be handed to <code>recover_data</code> via <code>ref_grid</code> or <code>emmeans</code> or a related function; and you may need to provide for if you don&#39;t use the <code>recover_data.call</code> function. The <code>data</code> argument is needed to cover a desperate situation that occurs with certain kinds of models where the underlying data information is not saved with the object&mdash;e.g., models that are fitted by iteratively modifying the data. In those cases, the only way to recover the data is to for the user to give it explicitly, and <code>recover_data</code> just adds a few needed attributes to it. </p>

<p>The <code>params</code> argument is needed when the model formula refers to variables besides predictors. For example, a model may include a spline term, and the knots are saved in the user&#39;s environment as a vector and referred to in the call to fit the model. In trying to recover the data, we try to construct a data frame containing all the variables present on the right-hand side of the model, but if some of those are scalars or of different lengths than the number of observations, an error occurs. So you need to exclude any names in <code>params</code> when reconstructing the data.</p>

<h4>Error handling {#rderrs}</h4>

<!-- @index `recover_data()!Error handling -->

<p>If you check for any error conditions in <code>recover_data</code>, simply have it return a character string with the desired message, rather than invoking <code>stop</code>. This provides a cleaner exit. The reason is that whenever <code>recover_data</code> throws an error, an informative message suggesting that <code>data</code> or <code>params</code> be provided is displayed. But a character return value is tested for and throws a different error with your string as the message.</p>

<h3>The <code>emm_basis</code> method {#ebreqs}</h3>

<!-- @index `emm_basis()`!Arguments and returned value -->

<p>The <code>emm_basis</code> method has four required arguments:</p>

<pre><code class="r">args(emmeans:::emm_basis.lm)
</code></pre>

<pre><code class="ro">## function (object, trms, xlev, grid, ...) 
## NULL
</code></pre>

<p>These are, respectively, the model object, its <code>terms</code> component (at least for the right-hand side of the model), a <code>list</code> of levels of the factors, and the grid of predictor combinations that specify the reference grid. </p>

<p>The function must obtain six things and return them in a named <code>list</code>. They are the matrix <code>X</code> of linear functions for each point in the reference grid, the regression coefficients <code>bhat</code>; the variance-covariance matrix <code>V</code>; a matrix <code>nbasis</code> for non-estimable functions; a function <code>dffun(k,dfargs)</code> for computing degrees of freedom for the linear function <code>sum(k*bhat)</code>; and a list <code>dfargs</code> of arguments to pass to <code>dffun</code>.</p>

<p>To write your own <code>emm_basis</code> function, examining some of the existing methods can help; but the best resource is the <code>predict</code> method for the object in question, looking carefully to see what it does to predict values for a new set of predictors (e.g., <code>newdata</code> in <code>predict.lm</code>). Following this advice, let&#39;s take a look at it:</p>

<pre><code class="r">MASS:::predict.lqs
</code></pre>

<pre><code class="ro">## function (object, newdata, na.action = na.pass, ...) 
## {
##     if (missing(newdata)) 
##         return(fitted(object))
##     Terms &lt;- delete.response(terms(object))
##     m &lt;- model.frame(Terms, newdata, na.action = na.action, xlev = object$xlevels)
##     if (!is.null(cl &lt;- attr(Terms, &quot;dataClasses&quot;))) 
##         .checkMFClasses(cl, m)
##     X &lt;- model.matrix(Terms, m, contrasts = object$contrasts)
##     drop(X %*% object$coefficients)
## }
## &lt;bytecode: 0x000000001bf2d6b0&gt;
## &lt;environment: namespace:MASS&gt;
</code></pre>

<h6>{#eblqs}</h6>

<!-- @index `emm_basis()`!for `lqs` objects@lqs -->

<p>Based on this, here is a listing of an <code>emm_basis</code> method for <code>lqs</code> objects:</p>

<pre><code class="r">emm_basis.lqs = function(object, trms, xlev, grid, ...) { 
    m = model.frame(trms, grid, na.action = na.pass, xlev = xlev)
    X = model.matrix(trms, m, contrasts.arg = object$contrasts) 
    bhat = coef(object) 
    Xmat = model.matrix(trms, data=object$model)                      # 5
    V = rev(object$scale)[1]^2 * solve(t(Xmat) %*% Xmat)
    nbasis = matrix(NA) 
    dfargs = list(df = nrow(Xmat) - ncol(Xmat))
    dffun = function(k, dfargs) dfargs$df
    list(X = X, bhat = bhat, nbasis = nbasis, V = V,                  #10
         dffun = dffun, dfargs = dfargs)
}
</code></pre>

<p>Before explaining it, let&#39;s verify that it works:</p>

<pre><code class="r">emmeans(fake.lts, ~ B | A)
</code></pre>

<pre><code class="ro">## A = a1:
##  B  emmean    SE df lower.CL upper.CL
##  b1   11.9 0.228 24     11.4     12.3
##  b2   23.1 0.228 24     22.6     23.6
##  b3   17.8 0.228 24     17.3     18.2
## 
## A = a2:
##  B  emmean    SE df lower.CL upper.CL
##  b1   13.9 0.228 24     13.4     14.4
##  b2   24.1 0.228 24     23.6     24.5
##  b3   20.5 0.228 24     20.0     21.0
## 
## Confidence level used: 0.95
</code></pre>

<p>Hooray! Note the results are comparable to those we had for <code>fake.rlm</code>, albeit the standard errors are quite a bit smaller. (In fact, the SEs could be misleading; a better method for estimating covariances should probably be implemented, but that is beyond the scope of this vignette.)</p>

<p><a href="#contents">Back to Contents</a></p>

<h3>Dissecting <code>emm_basis.lqs</code></h3>

<p>Let&#39;s go through the listing of this method, line-by-line:</p>

<ul>
<li>Lines 2&ndash;3: Construct the linear functions, <code>X</code>. This is a pretty standard 
two-step process: First obtain a model frame, <code>m</code>, for the grid of
predictors, then pass it as data to <code>model.matrix</code> to create the associated
design matrix. As promised, this code is essentially identical to what you
find in <code>predict.lqs</code>.</li>
<li>Line 4: Obtain the coefficients, <code>bhat</code>. Most model objects have a <code>coef</code> method.</li>
<li>Lines 5&ndash;6: Obtain the covariance matrix, <code>V</code>, of <code>bhat</code>. In many models,
this can be obtained using the object&#39;s <code>vcov</code> method. But not in this case.
Instead, I cobbled one together using the inverse of the <strong>X&#39;X</strong> matrix
as in ordinary regression, and the variance estimate found in the last
element of the <code>scale</code> element of the object. This probably under-estimates
the variances and distorts the covariances, because robust estimators have
some efficiency loss.</li>
<li><p>Line 7: Compute the basis for non-estimable functions. This applies only
when there is a possibility of rank deficiency in the model. But <code>lqs</code> methods
don&#39;t allow rank deficiencies, so it we have fitted such a model, we can be sure that
all linear functions are estimable; we signal that by
setting <code>nbasis</code> equal to a 1 x 1 matrix of <code>NA</code>. If rank deficiency were
possible, the <strong>estimability</strong> package (which is required by <strong>emmeans</strong>)
provides a <code>nonest.basis</code> function that makes this fairly painless&mdash;I would
have coded <code>nbasis = estimability::nonest.basis(Xmat)</code>. </p>

<p>There some subtleties you need to know regarding estimability. Suppose the model
is rank-deficient, so that the design matrix <strong>X</strong> has <em>p</em> columns but
rank <em>r</em> &lt; <em>p</em>. In that case, <code>bhat</code> should be of length <em>p</em> (not <em>r</em>), and there
should be <em>p</em> - <em>r</em> elements equal to <code>NA</code>, corresponding to columns of <strong>X</strong>
that were excluded from the fit. Also, <code>X</code> should have all <em>p</em> columns. In other
words, do not alter or throw-out columns of <code>X</code> or their corresponding elements
of <code>bhat</code>&mdash;even those with <code>NA</code> coefficients&mdash;as they are essential for
assessing estimability. <code>V</code> should be <em>r</em> x <em>r</em>, however&mdash;the covariance
matrix for the non-excluded predictors.</p></li>
<li><p>Lines 8&ndash;9: Obtain <code>dffun</code> and <code>dfargs</code>. This is a little awkward because it is     designed to allow support for mixed models, where approximate methods may be
used to obtain degrees of freedom. The function <code>dffun</code> is expected to have two
arguments: <code>k</code>, the vector of coefficients of <code>bhat</code>, and <code>dfargs</code>, a list
containing any additional arguments. In this case (and in many other models),
the degrees of freedom are the same regardless of <code>k</code>. We put the required
degrees of freedom in <code>dfargs</code> and write <code>dffun</code> so that it simply returns that
value. (Note: If asymptotic tests and CIs are desired, return <code>Inf</code>
degrees of freedom.)</p></li>
<li><p>Line 10: Return these results in a named list.</p></li>
</ul>

<p><a href="#contents">Back to Contents</a></p>

<h2>Communication between methods {#communic}</h2>

<!-- @index `emm_basis()`!Communicating with `recover_data()`;
   `recover_data()!Communicating with `emm_basis()`; `misc` attribute and argument -->

<p>If you need to pass information obtained in <code>recover_data()</code> to the <code>emm_basis()</code> method,
simply incorporate it as <code>attr(data, &quot;misc&quot;)</code> where <code>data</code> is the dataset returned by
<code>recover_data()</code>. Subsequently, that attribute is available in <code>emm_grid()</code> by adding a
<code>misc</code> argument.</p>

<h2>Hook functions {#hooks}</h2>

<!-- @index Hook functions; `emm_basis()`!Hook functions 
     `estHook`; `vcovHook`; `postGridHook` -->

<p>Most linear models supported by <strong>emmeans</strong> have straightforward structure: Regression coefficients, their covariance matrix, and a set of linear functions that define the reference grid. However, a few are more complex. An example is the <code>clm</code> class in the <strong>ordinal</strong> package, which allows a scale model in addition to the location model. When a scale model is used, the scale parameters are included in the model matrix, regression coefficients, and covariance matrix, and we can&#39;t just use the usual matrix operations to obtain estimates and standard errors. To facilitate using custom routines for these tasks, the <code>emm_basis.clm</code> function function provided in <strong>emmeans</strong> includes, in its <code>misc</code> part, the names (as character constants) of two &ldquo;hook&rdquo; functions: <code>misc$estHook</code> has the name of the function to call when computing estimates, standard errors, and degrees of freedom (for the <code>summary</code> method); and <code>misc$vcovHook</code> has the name of the function to call to obtain the covariance matrix of the grid values (used by the <code>vcov</code> method). These functions are called in lieu of the usual built-in routines for these purposes, and return the appropriately sized matrices. </p>

<p>In addition, you may want to apply some form of special post-processing after the reference grid is constructed. To provide for this, give the name of your function to post-process the object in <code>misc$postGridHook</code>. Again, <code>clm</code> objects (as well as <code>polr</code> in the <strong>MASS</strong> package) serve as an example. They allow a <code>mode</code> specification that in two cases, calls for post-processing. The <code>&quot;cum.prob&quot;</code> mode uses the <code>regrid</code> function to transform the linear predictor to the cumulative-probability scale. And the <code>&quot;prob&quot;</code> mode performs this, as well as applying the contrasts necessary to convert the cumulative probabilities into the class probabilities.</p>

<p><a href="#contents">Back to Contents</a></p>

<h2>Exported methods from <strong>emmeans</strong> {#exported}</h2>

<!-- @index **emmeans** package!Exports useful to developers -->

<p>For package developers&#39; convenience, <strong>emmeans</strong> exports some of its S3 methods
for <code>recover_data</code> and/or <code>emm_basis</code>&mdash;use <code>methods(&quot;recover_data&quot;)</code> and
<code>methods(&quot;emm_basis&quot;)</code> to discover which ones. It may be that all you need is to
invoke one of those methods and perhaps make some small changes&mdash;especially if
your model-fitting algorithm makes heavy use of an existing model type supported
by <strong>emmeans</strong>. For those methods that are not exported, use <code>recover_data()</code>
and <code>.emm_basis()</code>, which run in <strong>emmeans</strong>&#39;s namespace, thus providing access
to all available methods..</p>

<p>A few additional functions are exported because they may be useful to developers. They are as follows:</p>

<ul>
<li><p><code>emmeans::.all.vars(expr, retain)</code> Some users of your package may include <code>$</code> or
<code>[[]]</code> operators in their model formulas. If you need to get the variable
names, <code>base::all.vars</code> will probably not give you what you need. For
example, if <code>form = ~ data$x + data[[5]]</code>, then <code>base::all.vars(form)</code>
returns the names <code>&quot;data&quot;</code> and <code>&quot;x&quot;</code>, whereas <code>emmeans::.all.vars(form)</code>
returns the names <code>&quot;data$x&quot;</code> and <code>&quot;data[[5]]&quot;</code>. The <code>retain</code> argument may be
used to specify regular expressions for patterns to retain as parts of
variable names.</p></li>
<li><p><code>emmeans::.diag(x, nrow, ncol)</code> The base <code>diag</code> function has a booby trap whereby,
for example, <code>diag(57.6)</code> returns a 57 x 57 identity matrix rather than
a 1 x 1 matrix with 57.6 as its only element. But
<code>emmeans::.diag(57.6)</code> will return the latter. The function works identically
to <code>diag</code> except for its tail run around the identity-matrix trap.</p></li>
<li><p><code>emmeans::.aovlist.dffun(k, dfargs)</code> This function is exported because it is needed
for computing degrees of freedom for models fitted using <code>aov</code>, but it may be
useful for other cases where Satterthwaite degrees-of-freedom calculations are
needed. It requires the <code>dfargs</code> slot to contain analogous contents.</p></li>
<li><p><code>emmeans::.get.offset(terms, grid)</code> If <code>terms</code> is a model formula containing an
<code>offset</code> call, this is will compute that offset in the context of <code>grid</code> (a
<code>data.frame</code>).</p></li>
<li><p><code>emmeans::.my.vcov(object, ...)</code> In a call to <code>ref_grid</code>, <code>emmeans</code>, etc., the user may
use <code>vcov.</code> to specify an alternative function or matrix to use as the
covariance matrix of the fixed-effects coefficients. This function supports
that feature. Calling <code>.my.vcov</code> in place of the <code>vcov</code> method will
substitute the user&#39;s <code>vcov.</code> when it is specified.</p></li>
<li><p><code>emmeans::.std.link.labels(fam, misc)</code> This is useful in <code>emm_basis</code> methods for
generalized linear models. Call it with <code>fam</code> equal to the <code>family</code> object for
your model, and <code>misc</code> either an existing list, or just <code>list()</code> if none. It
returns a new <code>misc</code> list containing the link function and, in some cases,
extra features that are used for certain types of link functions (e.g., for a
log link, the setups for returning ratio comparisons with <code>type = &quot;response&quot;</code>).</p></li>
<li><p><code>emmeans::.num.key(levs, key)</code> Returns integer indices of elements of 
<code>key</code> in <code>levs</code> when <code>key</code> is a character vector; or just returns integer values
if already integer. Also throws an error if levels are mismatched or indices exceed 
legal range. This is useful in custom contrast functions (<code>.emmc</code> functions).</p></li>
<li><p><code>emmeans::.get.excl(levs, exclude, include)</code> This is support for the <code>exclude</code> and 
<code>include</code> arguments of contrast functions. It checks legality and returns an integer 
vector of <code>exclude</code> indices in <code>levs</code>, given specified integer or character
arguments <code>exclude</code> and <code>include</code>. In your <code>.emmc</code> function, 
<code>exclude</code> should default to <code>integer(0)</code> and <code>include</code> should have no default.</p></li>
</ul>

<p><a href="#contents">Back to Contents</a></p>

<h2>Existing support for <code>rsm</code> objects {#rsm}</h2>

<!-- @index **rsm** package -->

<p>As a nontrivial example of how an existing package supports <strong>emmeans</strong>, we show the support offered by the <strong>rsm</strong> package. Its <code>rsm</code> function  returns an <code>rsm</code> object which is an extension of the <code>lm</code> class. Part of that extension has to do with <code>coded.data</code> structures whereby, as is typical in response-surface analysis, models are fitted to variables that have been linearly transformed (coded) so that the scope of each predictor is
represented by plus or minus 1 on the coded scale. </p>

<p>Without any extra support in <strong>rsm</strong>, <code>emmeans</code> will work just fine with <code>rsm</code> objects; but if the data are coded, it becomes awkward to present results in terms of the original predictors on their original, uncoded scale. The <code>emmeans</code>-related methods in <strong>rsm</strong> provide a <code>mode</code> argument that may be used to specify whether we want to work with coded or uncoded data. The possible values for <code>mode</code> are <code>&quot;asis&quot;</code> (ignore any codings, if present), <code>&quot;coded&quot;</code> (use the coded scale), and <code>&quot;decoded&quot;</code> (use the decoded scale). The first two are actually the same in that no decoding is done; but it seems clearer to provide separate options because they represent two different situations.</p>

<h3>The <code>recover_data</code> method {#rdrsm}</h3>

<!-- @index `recover_data()`!for `rsm` objects@rsm -->

<p>Note that coding is a <em>predictor</em> transformation, not a response transformation (we could have that, too, as it&#39;s already supported by the <strong>emmeans</strong> infrastructure). So, to handle the <code>&quot;decode&quot;</code> mode, we will need to actually decode the predictors used to construct he reference grid. That means we need to make <code>recover_data</code> a lot fancier! Here it is:</p>

<pre><code class="r">recover_data.rsm = function(object, data, mode = c(&quot;asis&quot;, &quot;coded&quot;, &quot;decoded&quot;), ...) {
    mode = match.arg(mode)
    cod = rsm::codings(object)
    fcall = object$call
    if(is.null(data))                                                 # 5
        data = emmeans::recover_data(fcall, 
                   delete.response(terms(object)), object$na.action, ...)
    if (!is.null(cod) &amp;&amp; (mode == &quot;decoded&quot;)) {
        pred = cpred = attr(data, &quot;predictors&quot;)
        trms = attr(data, &quot;terms&quot;)                                    #10
        data = rsm::decode.data(rsm::as.coded.data(data, formulas = cod))
        for (form in cod) {
            vn = all.vars(form)
            if (!is.na(idx &lt;- grep(vn[1], pred))) { 
                pred[idx] = vn[2]                                     #15
                cpred = setdiff(cpred, vn[1])
            }
        }
        attr(data, &quot;predictors&quot;) = pred
        new.trms = update(trms, reformulate(c(&quot;1&quot;, cpred)))           #20
        attr(new.trms, &quot;orig&quot;) = trms
        attr(data, &quot;terms&quot;) = new.trms
        attr(data, &quot;misc&quot;) = cod
    }
    data
}
</code></pre>

<p>Lines 2&ndash;7 ensure that <code>mode</code> is legal, retrieves the codings from the object, and obtain the results we would get from <code>recover_data</code> had it been an <code>lm</code> object. If <code>mode</code> is not <code>&quot;decoded&quot;</code>, <em>or</em> if no codings were used, that&#39;s all we need. Otherwise, we need to return the decoded data. However, it isn&#39;t quite that simple, because the model equation is still defined on the coded scale. Rather than to try to translate the model coefficients and covariance matrix to the decoded scale, we elected to remember what we will need to do later to put things back on the coded scale. In lines 9&ndash;10, we retrieve the attributes of the recovered data that provide the predictor names and <code>terms</code> object on the coded scale. In line 11, we replace the recovered data with the decoded data. </p>

<p>By the way, the codings comprise a list of formulas with the coded name on the left and the original variable name on the right. It is possible that only some of the predictors are coded (for example, blocking factors will not be). In the <code>for</code> loop in lines 12&ndash;18, the coded predictor names are replaced with their decoded names. For technical reasons to be discussed later, we also remove these coded predictor names from a copy, <code>cpred</code>, of the list of all predictors in the coded model. In line 19, the <code>&quot;predictors&quot;</code> attribute of <code>data</code> is replaced with the modified version.</p>

<p>Now, there is a nasty technicality. The <code>ref_grid</code> function in <strong>emmeans</strong> has a few lines of code after <code>recover_data</code> is called that determine if any terms in the model convert covariates to factors or vice versa; and this code uses the model formula. That formula involves variables on the coded scale, and those variables are no longer present in the data, so an error will occur if it tries to access them. Luckily, if we simply take those terms out of the formula, it won&#39;t hurt because those coded predictors would not have been converted in that way. So in line 20, we update <code>trms</code> with a simpler model with the coded variables excluded (the intercept is explicitly included to ensure there will be a right-hand side even is <code>cpred</code> is empty). We save that as the <code>terms</code> attribute, and the original terms as a new <code>&quot;orig&quot;</code> attribute to be retrieved later. The <code>data</code> object, modified or not, is returned. If data have been decoded, <code>ref_grid</code> will construct its grid using decoded variables.</p>

<p>In line 23, we save the codings as the <code>&quot;misc&quot;</code> attribute, to be accessed later by <code>emm_basis()</code>.</p>

<h3>The <code>emm_basis</code> method {#ebrsm}</h3>

<!-- @index `emm_basis()`!for `rsm` objects@rsm -->

<p>Now comes the <code>emm_basis</code> method that will be called after the grid is defined. 
It is listed below:</p>

<pre><code class="r">emm_basis.rsm = function(object, trms, xlev, grid, 
                         mode = c(&quot;asis&quot;, &quot;coded&quot;, &quot;decoded&quot;), misc, ...) {
    mode = match.arg(mode)
    cod = misc
    if(!is.null(cod) &amp;&amp; mode == &quot;decoded&quot;) {                          # 5
        grid = rsm::coded.data(grid, formulas = cod)
        trms = attr(trms, &quot;orig&quot;)
    }

    m = model.frame(trms, grid, na.action = na.pass, xlev = xlev)     #10
    X = model.matrix(trms, m, contrasts.arg = object$contrasts)
    bhat = as.numeric(object$coefficients) 
    V = emmeans::.my.vcov(object, ...)

    if (sum(is.na(bhat)) &gt; 0)                                         #15
        nbasis = estimability::nonest.basis(object$qr)
    else
        nbasis = estimability::all.estble
    dfargs = list(df = object$df.residual)
    dffun = function(k, dfargs) dfargs$df                             #20

    list(X = X, bhat = bhat, nbasis = nbasis, V = V, 
         dffun = dffun, dfargs = dfargs, misc = list())
}
</code></pre>

<p>This is much simpler. The coding formulas are obtained from <code>misc</code> (line 4) so that we don&#39;t have to re-obtain them from the object. All we have to do is determine if decoding was done (line 5); and, if so, convert the grid back to the coded scale (line 6) and recover the original <code>terms</code> attribute (line 7). The rest is borrowed directly from the <code>emm_basis.lm</code> method in <strong>emmeans</strong>. Note that line 13 uses one of the exported functions we described in the preceding section. Lines 15&ndash;18 use functions from the <strong>estimability</strong> package to handle the possibility that the model is rank-deficient.</p>

<h3>A demonstration {#demo}</h3>

<p>Here&#39;s a demonstration of this <strong>rsm</strong> support. The standard example for <code>rsm</code> fits a second-order model <code>CR.rs2</code> to a dataset organized in two blocks and with two coded predictors.</p>

<pre><code class="r">library(&quot;rsm&quot;)
example(&quot;rsm&quot;)   ### (output is not shown) ###
</code></pre>

<p>First, let&#39;s look at some results on the coded scale&mdash;which are the same as for an ordinary <code>lm</code> object.</p>

<pre><code class="r">emmeans(CR.rs2, ~ x1 * x2, mode = &quot;coded&quot;, 
        at = list(x1 = c(-1, 0, 1), x2 = c(-2, 2)))
</code></pre>

<pre><code class="ro">##  x1 x2 emmean    SE df lower.CL upper.CL
##  -1 -2   75.0 0.298  7     74.3     75.7
##   0 -2   77.0 0.240  7     76.4     77.5
##   1 -2   76.4 0.298  7     75.6     77.1
##  -1  2   76.8 0.298  7     76.1     77.5
##   0  2   79.3 0.240  7     78.7     79.9
##   1  2   79.2 0.298  7     78.5     79.9
## 
## Results are averaged over the levels of: Block 
## Confidence level used: 0.95
</code></pre>

<p>Now, the coded variables <code>x1</code> and <code>x2</code> are derived from these coding formulas for predictors <code>Time</code> and <code>Temp</code>:</p>

<pre><code class="r">codings(CR.rs1)
</code></pre>

<pre><code class="ro">## $x1
## x1 ~ (Time - 85)/5
## 
## $x2
## x2 ~ (Temp - 175)/5
</code></pre>

<p>Thus, for example, a coded value of <code>x1 = 1</code> corresponds to a time of 85 + 1 x 5 = 90. Here are some results working with decoded predictors. Note that the <code>at</code> list must now be given in terms of <code>Time</code> and <code>Temp</code>:</p>

<pre><code class="r">emmeans(CR.rs2, ~ Time * Temp, mode = &quot;decoded&quot;, 
        at = list(Time = c(80, 85, 90), Temp = c(165, 185)))
</code></pre>

<pre><code class="ro">##  Time Temp emmean    SE df lower.CL upper.CL
##    80  165   75.0 0.298  7     74.3     75.7
##    85  165   77.0 0.240  7     76.4     77.5
##    90  165   76.4 0.298  7     75.6     77.1
##    80  185   76.8 0.298  7     76.1     77.5
##    85  185   79.3 0.240  7     78.7     79.9
##    90  185   79.2 0.298  7     78.5     79.9
## 
## Results are averaged over the levels of: Block 
## Confidence level used: 0.95
</code></pre>

<p>Since the supplied settings are the same on the decoded scale as were used on the coded scale, the EMMs are identical to those in the previous output.</p>

<h2>Exporting and registering your methods {#exporting}</h2>

<!-- @index **emmeans** package!Exporting extensions to 
     Registering `recover_data` and `emm_basis` methods -->

<p>To make the methods available to users of your package, the methods must be exported.
R and CRAN are evolving in a way that having S3 methods in the registry is
increasingly important; so it is a good idea to provide for that.
The problem is not all of your package users will have <strong>emmeans</strong> installed.
Thus, registering the methods must be done conditionally.</p>

<p>One solution is to list <code>emmeans</code> and <code>estimability</code> in the <code>Imports</code> field of your <code>DESCRIPTION</code> file.
Then, in the package <code>NAMESPACE</code> file, insert something like the following,
replacing &ldquo;foo&rdquo; with your object class name:</p>

<pre><code class="r">if (requireNamespace(&quot;emmeans&quot;, quietly = TRUE)) {
    importFrom(&quot;emmeans&quot;, &quot;recover_data&quot;, &quot;emm_basis&quot;)
    importFrom(&quot;estimability&quot;, &quot;all.estble&quot;, &quot;nonest.basis&quot;)
    S3method(recover_data, foo)
    S3method(emm_basis, foo)
}
</code></pre>

<p>(You can get by without testing <strong>estimability</strong> since it is already required by <strong>emmeans</strong>.)</p>

<p>The disadvantage of the above solution is that it adds several other packages as
dependencies. An alternative method that avoids those extra dependencies is as follows:
Put <code>emmeans</code> and
<code>estimability</code> in <code>Suggests</code> rather than <code>Imports</code>, and add code to
<em>dynamically</em> register the methods to one of your R source files (typically one
named <code>zzz.R</code>, the last source file to be read). Put code like this there:</p>

<pre><code class="r">register_s3_method &lt;- function(pkg, generic, class) {
    fun &lt;- get(paste0(generic, &quot;.&quot;, class), envir = parent.frame())
    if (isNamespaceLoaded(pkg))
        registerS3method(generic, class, fun, envir = asNamespace(pkg))
    # Also ensure registration is done if pkg is loaded later:
    setHook(
        packageEvent(pkg, &quot;onLoad&quot;),
        function(...)
            registerS3method(generic, class, fun, envir = asNamespace(pkg))
    )
}

.onLoad &lt;- function(libname, pkgname) {
    if (requireNamespace(&quot;emmeans&quot;, quietly = TRUE)) {
        register_s3_method(&quot;emmeans&quot;, &quot;recover_data&quot;, &quot;foo&quot;)
        register_s3_method(&quot;emmeans&quot;, &quot;emm_basis&quot;, &quot;foo&quot;)
    }
}

</code></pre>

<p>This code is adapted and simplified from the <strong>hms</strong> package. The original
<code>register_s3_method</code> function is more general and includes type-checking
of its arguments; but since this is just used internally, that checking
seems unnecessary.</p>

<p><a href="#contents">Back to Contents</a></p>

<h2>Conclusions {#concl}</h2>

<p>It is relatively simple to write appropriate methods that work with <strong>emmeans</strong> for model objects it does not support. I hope this vignette is helpful for understanding how. Furthermore, if you are the developer of a package that fits linear models, I encourage you to include <code>recover_data</code> and <code>emm_basis</code> methods for those classes of objects, so that users have access to <strong>emmeans</strong> support.</p>

<p><a href="#contents">Back to Contents</a></p>

<p><a href="vignette-topics.html">Index of all vignette topics</a></p>

</body>

</html>
