<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">

<head>

<meta charset="utf-8" />
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="pandoc" />

<meta name="viewport" content="width=device-width, initial-scale=1">

<meta name="author" content="emmeans package, Version 1.3.5.1" />


<title>Prediction in emmeans</title>






<style type="text/css">body {font-size: 11pt; font-family: "Palatino Linotype", "Book Antiqua", Palatino, serif;margin: 30px 50px 30px 50px; }h1,h2,h3,h4,h5,h6 { font-family: Arial,Helvetica,Sans-serif; }a { text-decoration: none; }a:link { color:darkblue; } a:visited { color:darkblue; } a:hover { color:dodgerblue; }a:active { color:dodgerblue; } code {color: #602000;font-family: "Lucida Console", Monaco, monospace; font-size: 90%;}.r { color: darkred; }.ro { color: darkgreen; background-color: #eeeeee; }.r code, a code, .ro code { color: inherit; }.vigindex ul { list-style-type: none; }.vigindex ul li { list-style: none; }.vigindex a code { color: inherit; }.vigindex li code { color: inherit; }</style>




</head>

<body>




<h1 class="title toc-ignore">Prediction in <strong>emmeans</strong></h1>
<h4 class="author">emmeans package, Version 1.3.5.1</h4>



<!-- @index Vignettes!Predictions -->
<p>In this vignette, we discuss <strong>emmeans</strong>’s rudimentary capabilities for constructing prediction intervals.</p>
<div id="contents" class="section level2">
<h2>Contents</h2>
<ol style="list-style-type: decimal">
<li><a href="#ref-grid">Focus on reference grids</a></li>
<li><a href="#sd-estimate">Need for an SD estimate</a></li>
<li><a href="#feedlot">Feedlot example</a></li>
<li><a href="#strata">Predictions on particular strata</a></li>
<li><a href="#bayes">Predictions with Bayesian models</a></li>
</ol>
<p><a href="vignette-topics.html">Index of all vignette topics</a></p>
</div>
<div id="ref-grid" class="section level2">
<h2>Focus on reference grids</h2>
<!-- @index Predictions!Reference grid; Reference grids!Prediction on -->
<p>Prediction is not the central purpose of the <strong>emmeans</strong> package. Even its name refers to the idea of obtaining marginal averages of fitted values; and it is a rare situation where one would want to make a prediction of the average of several observations. We can certainly do that if it is truly desired, but almost always, predictions should be based on the reference grid itself (i.e., <em>not</em> the result of an <code>emmeans()</code> call), inasmuch as a reference grid comprises combinations of model predictors.</p>
</div>
<div id="sd-estimate" class="section level2">
<h2>Need for an SD estimate</h2>
<!-- @index Predictions!Error SD; -->
<p>A prediction interval requires an estimate of the error standard deviation, because we need to account for both the uncertainty of our point predictions and the uncertainty of outcomes centered on those estimates. By its current design, we save the value (if any) returned by <code>stats::sigma(object)</code> when a reference grid is constructed for a model <code>object</code>. Not all models provide a <code>sigma()</code> method, in which case an error is thrown if the error SD is not manually specified. Also, in many cases, there may be a <code>sigma()</code> method, but it does not return the appropriate value(s) in the context of the needed predictions. (In an object returned by <code>lme4::glmer(), for example,</code>sigma()` seems to always returns 1.0.) Indeed, as will be seen in the example that follows, one usually needs to construct a manual SD estimate when the model is a mixed-effects model.</p>
<p>So it is essentially always important to think very specifically about whether we are using an appropriate value. You may check the value being assumed by looking at the <code>misc</code> slot in the reference grid:</p>
<pre class="r"><code>rg &lt;- ref_grid(model)
rg@misc$sigma</code></pre>
<p>Finally, <code>sigma</code> may be a vector, as long as it is conformable with the estimates in the reference grid. This would be appropriate, for example, with a model fitted by <code>nlme::gls()</code> with some kind of inhomogeneous error structure. It may take some effort, as well as a clear understanding of the model and its structure, to obtain suitable SD estimates. It was sugegsted to me that the function <code>insight::get_variance()</code> may be helpful – especially when working with an unfamiliar model class. Personally, I prefer to make sure I understand the structure of the model object and/or its summary to ensure I am not going astray.</p>
<p><a href="#contents">Back to Contents</a></p>
</div>
<div id="feedlot" class="section level2">
<h2>Feedlot example</h2>
<!-- @index Examples!`feedlot`; Predictions!Total SD; -->
<p>To illustrate, consider the <code>feedlot</code> dataset provided with the package. Here we have several herds of feeder cattle that are sent to feed lots and given one of three diets. The weights of the cattle are measured at time of entry (<code>ewt</code>) and at time of slaughter (<code>swt</code>). Different herds have possibly different entry weights, based on breed and ranching practices, so we will center each herd’s <code>ewt</code> measurements, then use that as a covariate in a mixed model:</p>
<pre class="r"><code>feedlot = transform(feedlot, adj.ewt = ewt - predict(lm(ewt ~ herd)))
require(lme4)
feedlot.lmer &lt;- lmer(swt ~ adj.ewt + diet + (1|herd), data = feedlot)
feedlot.rg &lt;- ref_grid(feedlot.lmer, at = list(adj.ewt = 0))
summary(feedlot.rg)  ## point predictions</code></pre>
<pre class="ro"><code>##  adj.ewt diet   prediction   SE   df
##        0 Low          1029 25.5 12.0
##        0 Medium        998 26.4 13.7
##        0 High         1031 29.4 19.9
## 
## Degrees-of-freedom method: kenward-roger</code></pre>
<p>Now, as advised, let’s look at the SDs involved in this model:</p>
<pre class="r"><code>lme4::VarCorr(feedlot.lmer)  ## for the model</code></pre>
<pre class="ro"><code>##  Groups   Name        Std.Dev.
##  herd     (Intercept) 77.087  
##  Residual             57.832</code></pre>
<pre class="r"><code>feedlot.rg@misc$sigma  ## default in the ref. grid</code></pre>
<pre class="ro"><code>## [1] 57.83221</code></pre>
<p>So the residual SD will be assumed in our prediction intervals if we don’t specify something else. And we <em>do</em> want something else, because in order to predict the slaughter weight of an arbitrary animal, without regard to its herd, we need to account for the variation among herds too, which is seen to be considerable. The two SDs reported by <code>VarCorr()</code> are assumed to represent independent sources of variation, so they may be combined into a total SD using the Pythagorean Theorem. We will update the reference grid with the new value:</p>
<pre class="r"><code>feedlot.rg &lt;- update(feedlot.rg, sigma = sqrt(77.087^2 + 57.832^2))</code></pre>
<p>We are now ready to form prediction intervals. To do so, simply call the <code>predict()</code> function with an <code>interval</code> argument:</p>
<pre class="r"><code>predict(feedlot.rg, interval = &quot;prediction&quot;)</code></pre>
<pre class="ro"><code>##  adj.ewt diet   prediction    SE   df lower.PL upper.PL
##        0 Low          1029  99.7 12.0      812     1247
##        0 Medium        998  99.9 13.7      783     1213
##        0 High         1031 100.7 19.9      821     1241
## 
## Degrees-of-freedom method: kenward-roger 
## Prediction intervals and SEs are based on an error SD of 96.369 
## Confidence level used: 0.95</code></pre>
<p>Note that the SEs for prediction are considerably greater than the SEs for estimation in the original summary of <code>feedlot.rg</code>. Also, as a sanity check, observe that these prediction intervals cover about the same ground as the original data:</p>
<pre class="r"><code>range(feedlot$swt)</code></pre>
<pre class="ro"><code>## [1]  816 1248</code></pre>
<p>By the way, we could have specified the desired <code>sigma</code> value as an additional <code>sigma</code> argument in the <code>predict()</code> call, rather than updating the <code>feedlot.rg</code> object.</p>
<p><a href="#contents">Back to Contents</a></p>
</div>
<div id="strata" class="section level2">
<h2>Predictions on particular strata</h2>
<!-- @index Predictions!on Particular strata -->
<p>Suppose, in our example, we want to predict <code>swt</code> for one or more particular herds. Then the total SD we computed is not appropriate for that purpose, because that includes variation among herds.</p>
<p>But more to the point, if we are talking about particular herds, then we are really regarding <code>herd</code> as a fixed effect of interest; so the expedient thing to do is to fit a different model where <code>herd</code> is a fixed effect:</p>
<pre class="r"><code>feedlot.lm &lt;- lm(swt ~ adj.ewt + diet + herd, data = feedlot)</code></pre>
<p>So to predict slaughter weight for herds <code>9</code> and <code>19</code>:</p>
<pre class="r"><code>newrg &lt;- ref_grid(feedlot.lm, at = list(adj.ewt = 0, herd = c(&quot;9&quot;, &quot;19&quot;)))
predict(newrg, interval = &quot;prediction&quot;, by = &quot;herd&quot;)</code></pre>
<pre class="ro"><code>## herd = 9:
##  adj.ewt diet   prediction   SE df lower.PL upper.PL
##        0 Low           867 63.6 53      740      995
##        0 Medium        835 64.1 53      707      964
##        0 High          866 66.3 53      733      999
## 
## herd = 19:
##  adj.ewt diet   prediction   SE df lower.PL upper.PL
##        0 Low          1069 62.1 53      945     1194
##        0 Medium       1037 62.8 53      911     1163
##        0 High         1068 64.0 53      940     1197
## 
## Prediction intervals and SEs are based on an error SD of 57.782 
## Confidence level used: 0.95</code></pre>
<p>This is an instance where the default <code>sigma</code> was already correct (being the only error SD we have available). The SD value is comparable to the residual SD in the previous model, and the prediction SEs are smaller than those for predicting over all herds.</p>
<p><a href="#contents">Back to Contents</a></p>
</div>
<div id="bayes" class="section level2">
<h2>Predictions with Bayesian models</h2>
<!-- @index Predictions!Bayesian models -->
<p>For models fitted using Bayesian methods, these kinds of prediction intervals are available only by forcing a frequentist analysis (<code>frequentist = TRUE</code>).</p>
<p>However, a better and more flexible approach with Bayesian models is to simulate observations from the posterior predictive distribution. This is done via <code>as.mcmc()</code> and specifying a <code>likelihood</code> argument. An example is given in the <a href="sophisticated.html#predict-mcmc">“sophisticated models” vignette</a>.</p>
<p><a href="#contents">Back to Contents</a></p>
<p><a href="vignette-topics.html">Index of all vignette topics</a></p>
</div>



<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
