<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">

<head>

<meta charset="utf-8" />
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="pandoc" />

<meta name="viewport" content="width=device-width, initial-scale=1">

<meta name="author" content="Russ Lenth" />

<meta name="date" content="2018-05-20" />

<title>Models supported by emmeans</title>






<link href="data:text/css;charset=utf-8,body%20%7B%0Afont%2Dsize%3A%2011pt%3B%20font%2Dfamily%3A%20%22Palatino%20Linotype%22%2C%20%22Book%20Antiqua%22%2C%20Palatino%2C%20serif%3B%0Amargin%3A%2030px%2050px%2030px%2050px%3B%20%7D%0Ah1%2Ch2%2Ch3%2Ch4%2Ch5%2Ch6%20%7B%20font%2Dfamily%3A%20Arial%2CHelvetica%2CSans%2Dserif%3B%20%7D%0Aa%20%7B%20text%2Ddecoration%3A%20none%3B%20%7D%0Aa%3Alink%20%7B%20color%3Adarkblue%3B%20%7D%20a%3Avisited%20%7B%20color%3Adarkblue%3B%20%7D%20a%3Ahover%20%7B%20color%3Adodgerblue%3B%20%7D%0Aa%3Aactive%20%7B%20color%3Adodgerblue%3B%20%7D%20code%20%7B%0Acolor%3A%20%23602000%3B%0Afont%2Dfamily%3A%20%22Lucida%20Console%22%2C%20Monaco%2C%20monospace%3B%20font%2Dsize%3A%2090%25%3B%0A%7D%0A%2Er%20%7B%20%0Acolor%3A%20darkred%3B%20%7D%0A%2Ero%20%7B%20%0Acolor%3A%20darkgreen%3B%20background%2Dcolor%3A%20%23eeeeee%3B%20%7D%0A%2Er%20code%2C%20a%20code%2C%20%2Ero%20code%20%7B%20color%3A%20inherit%3B%20%7D%0A%2Evigindex%20ul%20%7B%20list%2Dstyle%2Dtype%3A%20none%3B%20%7D%0A%2Evigindex%20ul%20li%20%7B%20list%2Dstyle%3A%20none%3B%20%7D%0A%2Evigindex%20a%20code%20%7B%20color%3A%20inherit%3B%20%7D%0A%2Evigindex%20li%20code%20%7B%20color%3A%20inherit%3B%20%7D%0A" rel="stylesheet" type="text/css" />

</head>

<body>




<h1 class="title toc-ignore">Models supported by emmeans</h1>
<h4 class="author"><em>Russ Lenth</em></h4>
<h4 class="date"><em>2018-05-20</em></h4>



<!-- @index Vignettes!Models -->
<p>Here we document what model objects may be used with <strong>emmeans</strong>, and some special features of some of them that may be accessed by passing additional arguments through <code>ref_grid</code> or <code>emmeans()</code>.</p>
<p>Certain objects are affected by optional arguments to functions that construct <code>emmGrid</code> objects, including <code>ref_grid()</code>, <code>emmeans()</code>, <code>emtrends()</code>, and <code>emmip()</code>. When “<em>arguments</em>” are mentioned in the subsequent quick reference and object-by-object documentation, we are talking about arguments in these constructors.</p>
<p>Additional models can be supported by writing appropriate <code>recover_data</code> and <code>emm_basis</code> methods. See the package documentation for <code>extending-emmeans</code> and <code>vignette(&quot;extending&quot;)</code> for details.</p>
<p><a href="vignette-topics.html">Index of all vignette topics</a></p>
<div id="quickref" class="section level2">
<h2>Quick reference for supported objects and options</h2>
<!-- @index Models!Quick reference -->
<p>Here is an alphabetical list of model classes that are supported, and the arguments that apply. Detailed documentation follows, with objects grouped by the code in the “Group” column. Scroll down or follow the links to those groups for more information.</p>
<table>
<thead>
<tr class="header">
<th align="left">Object.class</th>
<th align="left">Package</th>
<th align="center">Group</th>
<th align="left">Arguments / notes</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">aov</td>
<td align="left">stats</td>
<td align="center"><a href="#A">A</a></td>
<td align="left"></td>
</tr>
<tr class="even">
<td align="left">aovList</td>
<td align="left">stats</td>
<td align="center"><a href="#V">V</a></td>
<td align="left">Best with balanced designs, orthogonal coding</td>
</tr>
<tr class="odd">
<td align="left">betareg</td>
<td align="left">betareg</td>
<td align="center"><a href="#B">B</a></td>
<td align="left"><code>mode = c(&quot;link&quot;, &quot;precision&quot;, &quot;phi.link&quot;,</code></td>
</tr>
<tr class="even">
<td align="left"></td>
<td align="left"></td>
<td align="center"></td>
<td align="left"><code>&quot;variance&quot;, &quot;quantile&quot;)</code></td>
</tr>
<tr class="odd">
<td align="left">brmsfit</td>
<td align="left">brms</td>
<td align="center"><a href="#S">S</a></td>
<td align="left">Only simpler models</td>
</tr>
<tr class="even">
<td align="left">carbayes</td>
<td align="left">CARBayes</td>
<td align="center"><a href="#S">S</a></td>
<td align="left"><code>data</code> is required</td>
</tr>
<tr class="odd">
<td align="left">clm</td>
<td align="left">ordinal</td>
<td align="center"><a href="#O">O</a></td>
<td align="left"><code>mode = c(&quot;latent&quot;, &quot;linear.predictor&quot;, &quot;cum.prob&quot;,</code></td>
</tr>
<tr class="even">
<td align="left"></td>
<td align="left"></td>
<td align="center"></td>
<td align="left"><code>&quot;exc.prob&quot;, &quot;prob&quot;, &quot;mean.class&quot;, &quot;scale&quot;)</code></td>
</tr>
<tr class="odd">
<td align="left">clmm</td>
<td align="left">ordinal</td>
<td align="center"><a href="#O">O</a></td>
<td align="left">Like <code>clm</code> but no <code>&quot;scale&quot;</code> mode</td>
</tr>
<tr class="even">
<td align="left">coxme</td>
<td align="left">coxme</td>
<td align="center"><a href="#G">G</a></td>
<td align="left"></td>
</tr>
<tr class="odd">
<td align="left">coxph</td>
<td align="left">survival</td>
<td align="center"><a href="#G">G</a></td>
<td align="left"></td>
</tr>
<tr class="even">
<td align="left">gam</td>
<td align="left">gam</td>
<td align="center"><a href="#G">G</a></td>
<td align="left"><code>nboot = 800</code></td>
</tr>
<tr class="odd">
<td align="left">gamlss</td>
<td align="left">gamlss</td>
<td align="center"><a href="#H">H</a></td>
<td align="left"><code>what = c(&quot;mu&quot;, &quot;sigma&quot;, &quot;nu&quot;, &quot;tau&quot;)</code></td>
</tr>
<tr class="even">
<td align="left">gee</td>
<td align="left">gee</td>
<td align="center"><a href="#E">E</a></td>
<td align="left"><code>vcov.method = c(&quot;naive&quot;, &quot;robust&quot;)</code></td>
</tr>
<tr class="odd">
<td align="left">geeglm</td>
<td align="left">geepack</td>
<td align="center"><a href="#E">E</a></td>
<td align="left"><code>vcov.method = c(&quot;vbeta&quot;, &quot;vbeta.naiv&quot;, &quot;vbeta.j1s&quot;,</code></td>
</tr>
<tr class="even">
<td align="left"></td>
<td align="left"></td>
<td align="center"></td>
<td align="left"><code>&quot;vbeta.fij&quot;, &quot;robust&quot;, &quot;naive&quot;)</code> or a matrix</td>
</tr>
<tr class="odd">
<td align="left">geese</td>
<td align="left">geepack</td>
<td align="center"><a href="#E">E</a></td>
<td align="left">Like <code>geeglm</code></td>
</tr>
<tr class="even">
<td align="left">glm</td>
<td align="left">stats</td>
<td align="center"><a href="#G">G</a></td>
<td align="left"></td>
</tr>
<tr class="odd">
<td align="left">glm.nb</td>
<td align="left">MASS</td>
<td align="center"><a href="#G">G</a></td>
<td align="left">Requires <code>data</code> argument</td>
</tr>
<tr class="even">
<td align="left">glmmadmb</td>
<td align="left">glmmADMB</td>
<td align="center"><a href="#G">G</a></td>
<td align="left"></td>
</tr>
<tr class="odd">
<td align="left">glmerMod</td>
<td align="left">lme4</td>
<td align="center"><a href="#G">G</a></td>
<td align="left"></td>
</tr>
<tr class="even">
<td align="left">glmmPQL</td>
<td align="left">MASS</td>
<td align="center"><a href="#G">G</a></td>
<td align="left">inherits <code>lm</code> support</td>
</tr>
<tr class="odd">
<td align="left">gls</td>
<td align="left">nlme</td>
<td align="center"><a href="#G">G</a></td>
<td align="left"></td>
</tr>
<tr class="even">
<td align="left">hurdle</td>
<td align="left">pscl</td>
<td align="center"><a href="#C">C</a></td>
<td align="left"><code>mode = c(&quot;response&quot;, &quot;count&quot;, &quot;zero&quot;, &quot;prob0&quot;),</code></td>
</tr>
<tr class="odd">
<td align="left"></td>
<td align="left"></td>
<td align="center"></td>
<td align="left"><code>lin.pred = c(FALSE, TRUE)</code></td>
</tr>
<tr class="even">
<td align="left">lm</td>
<td align="left">stats</td>
<td align="center"><a href="#A">A</a></td>
<td align="left">Several other classes inherit from this and may be supported</td>
</tr>
<tr class="odd">
<td align="left">lme</td>
<td align="left">nlme</td>
<td align="center"><a href="#K">K</a></td>
<td align="left"><code>sigmaAdjust = c(TRUE, FALSE),</code></td>
</tr>
<tr class="even">
<td align="left"></td>
<td align="left"></td>
<td align="center"></td>
<td align="left"><code>mode = c(&quot;containment&quot;, &quot;satterthwaite&quot;)</code> (<em>ad hoc</em>)</td>
</tr>
<tr class="odd">
<td align="left">lmerMod</td>
<td align="left">lme4</td>
<td align="center"><a href="#L">L</a></td>
<td align="left"><code>lmer.df = c(&quot;kenward-roger&quot;, &quot;satterthwaite&quot;, &quot;asymptotic&quot;)</code>,</td>
</tr>
<tr class="even">
<td align="left"></td>
<td align="left"></td>
<td align="center"></td>
<td align="left"><code>pbkrtest.limit = 3000</code>, <code>disable.pbkrtest = FALSE</code>.</td>
</tr>
<tr class="odd">
<td align="left"></td>
<td align="left"></td>
<td align="center"></td>
<td align="left"><code>emm_options(lmer.df =, pbkrtest.limit =, disable.pbkrtest =)</code></td>
</tr>
<tr class="even">
<td align="left">manova</td>
<td align="left">stats</td>
<td align="center"><a href="#M">M</a></td>
<td align="left"><code>mult.name</code>, <code>mult.levs</code></td>
</tr>
<tr class="odd">
<td align="left">maov</td>
<td align="left">stats</td>
<td align="center"><a href="#M">M</a></td>
<td align="left"><code>mult.name</code>, <code>mult.levs</code></td>
</tr>
<tr class="even">
<td align="left">mcmc</td>
<td align="left">mcmc</td>
<td align="center"><a href="#S">S</a></td>
<td align="left">May require <code>formula</code>, <code>data</code></td>
</tr>
<tr class="odd">
<td align="left">MCMCglmm</td>
<td align="left">MCMCglmm</td>
<td align="center"><a href="#M">M</a>,<a href="#S">S</a></td>
<td align="left"><code>mult.name</code>, <code>mult.levs</code></td>
</tr>
<tr class="even">
<td align="left"></td>
<td align="left"></td>
<td align="center"></td>
<td align="left"><code>data</code> is required</td>
</tr>
<tr class="odd">
<td align="left">mixed</td>
<td align="left">afex</td>
<td align="center"><a href="#P">P</a></td>
<td align="left">Supported in <strong>afex</strong> package</td>
</tr>
<tr class="even">
<td align="left">mlm</td>
<td align="left">stats</td>
<td align="center"><a href="#M">M</a></td>
<td align="left"><code>mult.name</code>, <code>mult.levs</code></td>
</tr>
<tr class="odd">
<td align="left">multinom</td>
<td align="left">nnet</td>
<td align="center"><a href="#N">N</a></td>
<td align="left"><code>mode = c(&quot;prob&quot;, &quot;latent&quot;)</code></td>
</tr>
<tr class="even">
<td align="left"></td>
<td align="left"></td>
<td align="center"></td>
<td align="left">Always include response in specs for <code>emmeans()</code></td>
</tr>
<tr class="odd">
<td align="left">nauf</td>
<td align="left">nauf.<em>xxx</em></td>
<td align="center"><a href="#P">P</a></td>
<td align="left">Supported in <strong>nauf</strong> package</td>
</tr>
<tr class="even">
<td align="left">nlme</td>
<td align="left">nlme</td>
<td align="center"><a href="#A">A</a></td>
<td align="left">Supports fixed part. Requires <code>param</code></td>
</tr>
<tr class="odd">
<td align="left">polr</td>
<td align="left">MASS</td>
<td align="center"><a href="#O">O</a></td>
<td align="left"><code>mode = c(&quot;latent&quot;, &quot;linear.predictor&quot;, &quot;cum.prob&quot;,</code></td>
</tr>
<tr class="even">
<td align="left"></td>
<td align="left"></td>
<td align="center"></td>
<td align="left"><code>&quot;exc.prob&quot;, &quot;prob&quot;, &quot;mean.class&quot;)</code></td>
</tr>
<tr class="odd">
<td align="left">rlm</td>
<td align="left">MASS</td>
<td align="center"><a href="#A">A</a></td>
<td align="left">inherits <code>lm</code> support</td>
</tr>
<tr class="even">
<td align="left">rms</td>
<td align="left">rms</td>
<td align="center"><a href="#O">O</a></td>
<td align="left"><code>mode = (&quot;middle&quot;, &quot;latent&quot;, &quot;linear.predictor&quot;,</code></td>
</tr>
<tr class="odd">
<td align="left"></td>
<td align="left"></td>
<td align="center"></td>
<td align="left"><code>&quot;cum.prob&quot;, &quot;exc.prob&quot;, &quot;prob&quot;, &quot;mean.class&quot;)</code></td>
</tr>
<tr class="even">
<td align="left">rsm</td>
<td align="left">rsm</td>
<td align="center"><a href="#P">P</a></td>
<td align="left">Supported in <strong>rsm</strong> package</td>
</tr>
<tr class="odd">
<td align="left">stanreg</td>
<td align="left">rstanarm</td>
<td align="center"><a href="#S">S</a></td>
<td align="left">Args for <code>stanreg_</code><em>xxx</em> similar to those for <em>xxx</em></td>
</tr>
<tr class="even">
<td align="left">survreg</td>
<td align="left">survival</td>
<td align="center"><a href="#A">A</a></td>
<td align="left"></td>
</tr>
<tr class="odd">
<td align="left">zeroinfl</td>
<td align="left">pscl</td>
<td align="center"><a href="#C">C</a></td>
<td align="left"><code>mode = c(&quot;response&quot;, &quot;count&quot;, &quot;zero&quot;, &quot;prob0&quot;)</code>,</td>
</tr>
<tr class="even">
<td align="left"></td>
<td align="left"></td>
<td align="center"></td>
<td align="left"><code>lin.pred = c(FALSE, TRUE)</code></td>
</tr>
</tbody>
</table>
</div>
<div id="A" class="section level2">
<h2>Group A – “Standard” models (typically linear and mixed)</h2>
<p>Models in this group, such as <code>lm</code>, do not have unusual features that need special support; hence no extra arguments are needed.</p>
</div>
<div id="B" class="section level2">
<h2>B – Beta regression</h2>
<!-- @index Beta regression; `betareg` models -->
<p>The additional <code>mode</code> argument for <code>betareg</code> objects has possible values of <code>&quot;response&quot;</code>, <code>&quot;link&quot;</code>, <code>&quot;precision&quot;</code>, <code>&quot;phi.link&quot;</code>, <code>&quot;variance&quot;</code>, and <code>&quot;quantile&quot;</code>, which have the same meaning as the <code>type</code> argument in <code>predict.betareg</code> – with the addition that <code>&quot;phi.link&quot;</code> is like <code>&quot;link&quot;</code>, but for the precision portion of the model. When <code>mode = &quot;quantile&quot;</code> is specified, the additional argument <code>quantile</code> (a numeric scalar or vector) specifies which quantile(s) to compute; the default is 0.5 (the median). Also in <code>&quot;quantile&quot;</code> mode, an additional variable <code>quantile</code> is added to the reference grid, and its levels are the values supplied.</p>
<p><a href="#quickref">Back to quick reference</a></p>
</div>
<div id="C" class="section level2">
<h2>Group C – Count models</h2>
<!-- @index Count regression; `hurdle` models; `zeroinfl` models -->
<p>Two optional arguments – <code>mode</code> and <code>lin.pred</code> – are provided. The <code>mode</code> argument has possible values <code>&quot;response&quot;</code> (the default), <code>&quot;count&quot;</code>, <code>&quot;zero&quot;</code>, or <code>&quot;prob0&quot;</code>. <code>lin.pred</code> is logical and defaults to <code>FALSE</code>.</p>
<p>With <code>lin.pred = FALSE</code>, the results are comparable to those returned by <code>predict(..., type = &quot;response&quot;)</code>, <code>predict(..., type = &quot;count&quot;)</code>, <code>predict(..., type = &quot;zero&quot;)</code>, or <code>predict(..., type = &quot;prob&quot;)[, 1]</code>. See the documentation for <code>predict.hurdle</code> and <code>predict.zeroinfl</code>.</p>
<p>The option <code>lin.pred = TRUE</code> only applies to <code>mode = &quot;count&quot;</code> and <code>mode = &quot;zero&quot;</code>. The results returned are on the linear-predictor scale, with the same transformation as the link function in that part of the model. The predictions for a reference grid with <code>mode = &quot;count&quot;</code>, <code>lin.pred = TRUE</code>, and <code>type = &quot;response&quot;</code> will be the same as those obtained with <code>lin.pred = FALSE</code> and <code>mode = &quot;count&quot;</code>; however, any EMMs derived from these grids will be different, because the averaging is done on the log-count scale and the actual count scale, respectively – thereby producing geometric means versus arithmetic means of the predictions.</p>
<p>If the <code>vcov.</code> argument is used (see details in the documentation for <code>ref_grid</code>), it must yield a matrix of the same size as would be obtained using <code>vcov.hurdle</code> or <code>vcov.zeroinfl</code> with its <code>model</code> argument set to <code>(&quot;full&quot;, &quot;count&quot;, &quot;zero&quot;)</code> in respective correspondence with <code>mode</code> of <code>(&quot;mean&quot;, &quot;count&quot;, &quot;zero&quot;)</code>. If <code>vcov.</code> is a function, it must support the <code>model</code> argument.</p>
<p><a href="#quickref">Back to quick reference</a></p>
</div>
<div id="E" class="section level2">
<h2>Group E – GEE models</h2>
<!-- @index GEE models -->
<p>These models all have more than one covariance estimate available, and it may be selected by supplying a string as the <code>vcov.method</code> argument. It is partially matched with the available choices shown in the quick reference. In <code>geese</code> and <code>geeglm</code>, the aliases <code>&quot;robust&quot;</code> (for <code>&quot;vbeta&quot;</code>) and <code>&quot;naive&quot;</code> (for <code>&quot;vbeta.naiv&quot;</code> are also accepted.</p>
<p>If a matrix or function is supplied as <code>vcov.method</code>, it is interpreted as a <code>vcov.</code> specification as described for <code>...</code> in the documentation for <code>ref_grid</code>.</p>
</div>
<div id="G" class="section level2">
<h2>Group G – Generalized linear models and relatives</h2>
<!-- @index Generalized linear models; `glm`*xxx* models -->
<p>Models in this group receive only standard support as in <a href="#A">Group A</a>, but typically the tests and confidence intervals are asymptotic. Thus the <code>df</code> column for tabular results will be <code>Inf</code>.</p>
<p>In the case of <code>gam::gam</code> objects, there is an optional <code>nboot</code> argument that sets the number of bootstrap replications used to estimate the variances and covariances of the smoothing portions of the model.</p>
<p><a href="#quickref">Back to quick reference</a></p>
</div>
<div id="H" class="section level2">
<h2>Group H – <code>gamlss</code> models</h2>
<!-- @index `gamlss` models -->
<p>The <code>what</code> argument has possible values of <code>&quot;mu&quot;</code> (default), <code>&quot;sigma&quot;</code>, <code>&quot;nu&quot;</code>, or <code>&quot;tau&quot;</code> depending on which part of the model you want results for. Currently, there is no support when the selected part of the model contains a smoothing method like <code>pb()</code>.</p>
</div>
<div id="K" class="section level2">
<h2>Group K – <code>lme</code> models</h2>
<!-- @index `lme` models; `gls` models; Satterthwaite d.f. -->
<p>The <code>sigmaAdjust</code> argument is a logical value that defaults to <code>TRUE</code>. It is comparable to the <code>adjustSigma</code> option in <code>nlme::summary.lme</code> (the name-mangling is to avoid conflicts with the often-used <code>adjust</code> argument), and determines whether or not a degrees-of-freedom adjustment is performed with models fitted using the ML method.</p>
<p>The optional <code>mode</code> argument affects the degrees of freedom. It defaults to <code>&quot;containment&quot;</code>, which determines the degrees of freedom for the coarsest grouping involved in the contrast or linear functuion involved. There is an experimental <code>mode = &quot;satterthwaite&quot;</code> option that determines degrees of freedom approximately: It estimates a needed gradient in the covariance matrix experimentally by randomly perturbing the response values. Thus, the degrees of freedom will vary slightly (or possibly even a lot) if the reference grid is re-calculated.</p>
<p><a href="#quickref">Back to quick reference</a></p>
</div>
<div id="L" class="section level2">
<h2>Group L – <code>lmerMod</code> models</h2>
<!-- @index `lmerMod` models; Kenward-Roger d.f.; Satterthwaite d.f. -->
<p>There is an optional <code>lmer.df</code> argument that defaults to <code>get_EMM_option(&quot;lmer.df&quot;)</code> (which in turn defaults to <code>&quot;kenward-roger&quot;</code>). The possible values are <code>&quot;kenward-roger&quot;</code>, <code>&quot;satterthwaite&quot;</code>, and <code>&quot;asymptotic&quot;</code> (these are partially matched and case-insensitive). With <code>&quot;kenward-roger&quot;</code>, d.f. are obtained using code from the <strong>pbkrtest</strong> package, if installed. With <code>&quot;satterthwaite&quot;</code>, d.f. are obtained using code from the <strong>lmerTest</strong> package, if installed. With <code>&quot;asymptotic&quot;</code>, or if the needed package is not installed, d.f. are set to <code>Inf</code>. (For backward compatibility, the user may specify <code>mode</code> in lieu of <code>lmer.df</code>.)</p>
<p>A by-product of the Kenward-Roger method is that the covariance matrix is adjusted using <code>pbkrtest::vcovAdj()</code>. This can require considerable computation; so to avoid that overhead, the user should opt for the Satterthwaite or asymptotic method; or, for backward compatibility, may disable the use of <strong>pbkrtest</strong> via <code>emm_options(disable.pbkrtest = TRUE)</code> (this does not disable the <strong>pbkrtest</strong> package entirely, just its use in <strong>emmeans</strong>). The computation time required depends roughly on the number of observations, <em>N</em>, in the design matrix (because a major part of the computation involves inverting an <em>N</em> x <em>N</em> matrix). Thus, <strong>pbkrtest</strong> is automatically disabled if <em>N</em> exceeds the value of <code>get_emm_option(&quot;pbkrtest.limit&quot;)</code>, for which the factory default is 3000.</p>
<p>Similarly to the above, the <code>disable.lmerTest</code> and <code>lmerTest.limit</code> options affect whether Satterthwaite methods can be implemented.</p>
<p>The <code>df</code> argument may be used to specify some other degrees of freedom. Note that if <code>df</code> and <code>method = &quot;satterthwaite&quot;</code> are both specified, the covariance matrix is adjusted but the K-R degrees of freedom are not used.</p>
<p>Finally, note that a user-specified covariance matrix (via the <code>vcov.</code> argument) will also disable the Kenward-Roger method; in that case, the Satterthwaite method is used in place of Kenward-Roger.</p>
<p><a href="#quickref">Back to quick reference</a></p>
</div>
<div id="M" class="section level2">
<h2>Group M – Multivariate models</h2>
<!-- @index Multivariate models -->
<p>When there is a multivariate response, the different responses are treated as if they were levels of a factor – named <code>rep.meas</code> by default. The <code>mult.name</code> argument may be used to change this name. The <code>mult.levs</code> argument may specify a named list of one or more sets of levels. If this has more than one element, then the multivariate levels are expressed as combinations of the named factor levels via the function <code>base::expand.grid</code>.</p>
</div>
<div id="N" class="section level2">
<h2>N - Multinomial responses</h2>
<!-- @index `mlm` models; Multinomial models -->
<p>The reference grid includes a pseudo-factor with the same name and levels as the multinomial response. There is an optional <code>mode</code> argument which should match <code>&quot;prob&quot;</code> or <code>&quot;latent&quot;</code>. With <code>mode = &quot;prob&quot;</code>, the reference-grid predictions consist of the estimated multinomial probabilities. The <code>&quot;latent&quot;</code> mode returns the linear predictor, recentered so that it averages to zero over the levels of the response variable (similar to sum-to-zero contrasts). Thus each latent variable can be regarded as the log probability at that level minus the average log probability over all levels.</p>
<p>There are two optional arguments: <code>mode</code> and <code>rescale</code> (which defaults to <code>c(0, 1)</code>).</p>
<p>Please note that, because the probabilities sum to 1 (and the latent values sum to 0) over the multivariate-response levels, all sensible results from <code>emmeans()</code> must involve that response as one of the factors. For example, if <code>resp</code> is a response with <em>k</em> levels, <code>emmeans(model, ~ resp | trt)</code> will yield the estimated multinomial distribution for each <code>trt</code>; but <code>emmeans(model, ~ trt)</code> will just yield the average probability of 1/<em>k</em> for each <code>trt</code>.</p>
<p><a href="#quickref">Back to quick reference</a></p>
</div>
<div id="O" class="section level2">
<h2>Group O - Ordinal responses</h2>
<!-- @index Ordinal models; `clm` models; `polreg` models -->
<p>The reference grid for ordinal models will include all variables that appear in the main model as well as those in the <code>scale</code> or <code>nominal</code> models (if provided). There are two optional arguments: <code>mode</code> (a character string) and <code>rescale</code> (which defaults to <code>c(0, 1)</code>). <code>mode</code> should match one of <code>&quot;latent&quot;</code> (the default), <code>&quot;linear.predictor&quot;</code>, <code>&quot;cum.prob&quot;</code>, <code>&quot;exc.prob&quot;</code>, <code>&quot;prob&quot;</code>, <code>&quot;mean.class&quot;</code>, or <code>&quot;scale&quot;</code> – see the quick reference and note which are supported.</p>
<p>With <code>mode = &quot;latent&quot;</code>, the reference-grid predictions are made on the scale of the latent variable implied by the model. The scale and location of this latent variable are arbitrary, and may be altered via <code>rescale</code>. The predictions are multiplied by <code>rescale[2]</code>, then added to <code>rescale[1]</code>. Keep in mind that the scaling is related to the link function used in the model; for example, changing from a probit link to a logistic link will inflate the latent values by around <span class="math inline">\(\pi/\sqrt{3}\)</span>, all other things being equal. <code>rescale</code> has no effect for other values of <code>mode</code>.</p>
<p>With <code>mode = &quot;linear.predictor&quot;</code>, <code>mode = &quot;cum.prob&quot;</code>, and <code>mode = &quot;exc.prob&quot;</code>, the boundaries between categories (i.e., thresholds) in the ordinal response are included in the reference grid as a pseudo-factor named <code>cut</code>. The reference-grid predictions are then of the cumulative probabilities at each threshold (for <code>mode = &quot;cum.prob&quot;</code>), exceedance probabilities (one minus cumulative probabilities, for <code>mode = &quot;exc.prob&quot;</code>), or the link function thereof (for <code>mode = &quot;linear.predictor&quot;</code>).</p>
<p>With <code>mode = &quot;prob&quot;</code>, a pseudo-factor with the same name as the model’s response variable is created, and the grid predictions are of the probabilities of each class of the ordinal response. With <code>&quot;mean.class&quot;</code>, the returned results are means of the ordinal response, interpreted as a numeric value from 1 to the number of classes, using the <code>&quot;prob&quot;</code> results as the estimated probability distribution for each case.</p>
<p>With <code>mode = &quot;scale&quot;</code>, and the fitted object incorporates a scale model, EMMs are obtained for the factors in the scale model (with a log response) instead of the response model. The grid is constructed using only the factors in the scale model.</p>
<p>Any grid point that is non-estimable by either the location or the scale model (if present) is set to <code>NA</code>, and any EMMs involving such a grid point will also be non-estimable. A consequence of this is that if there is a rank-deficient <code>scale</code> model, then <em>all</em> latent responses become non-estimable because the predictions are made using the average log-scale estimate.</p>
<p><code>rms</code> models have an additional <code>mode</code>. With <code>mode = &quot;middle&quot;</code> (this is the default), the middle intercept is used, comparable to the default for <code>rms::Predict()</code>. This is quite similar in concept to <code>mode = &quot;latent&quot;</code>, where all intercepts are averaged together.</p>
<p><a href="#quickref">Back to quick reference</a></p>
</div>
<div id="P" class="section level2">
<h2>P – Other packages</h2>
<p>Models in this group have their <strong>emmeans</strong> support provided by the package that implements the model-fitting procedure. Users should refer to the package documentation for details on <strong>emmeans</strong> support.</p>
</div>
<div id="S" class="section level2">
<h2>S – Sampling (MCMC) methods</h2>
<!-- @index Bayesian models; `mcmc` objects; `stanreg` objects; `brmsfit` objects
  `as.mcmc()`; `summary()`!Bayesian models -->
<p>Models fitted using MCMC methods contain a sample from the posterior distribution of fixed-effect coefficients. In some cases (e.g., results of <code>MCMCpack::MCMCregress()</code> and <code>MCMCpack::MCMCpoisson()</code>), the object may include a <code>&quot;call&quot;</code> attribute that <code>emmeans()</code> can use to reconstruct the data and obtain a basis for the EMMs. If not, a <code>formula</code> and <code>data</code> argument are provided that may help produce the right results. In addition, the <code>contrasts</code> specifications are not necessarily recoverable from the object, so the system default must match what was actually used in fitting the model.</p>
<p>The <code>summary.emmGrid()</code> method provides credibility intervals (HPD intervals) of the results, and ignores the frequentist-oriented arguments (<code>infer</code>, <code>adjust</code>, etc.) An <code>as.mcmc()</code> method is provided that creates an <code>mcmc</code> object that can be summarized or plotted using the <strong>coda</strong> package (or others that support those objects). It provides a posterior sample of EMMs, or contrasts thereof, for the given reference grid, based on the posterior sample of the fixed effects from the model object.</p>
<p>Support for the <strong>brms</strong> package is provided but it is quite rudimentary and usable only for the primary fixed effects and the simpler models.</p>
<p><a href="#quickref">Back to quick reference</a></p>
</div>
<div id="V" class="section level2">
<h2>Group V – <code>aovList</code> objects</h2>
<!-- @index `aovList` objects -->
<p>Support for these objects is limited. To avoid strong biases in the predictions, the <code>contrasts</code> attribute of all factors should be of a type that sums to zero – for example, <code>&quot;contr.sum&quot;</code>, <code>&quot;contr.poly&quot;</code>, or <code>&quot;contr.helmert&quot;</code> but <em>not</em> <code>&quot;contr.treatment&quot;</code>. Only intra-block estimates of covariances are used. That is, if a factor appears in more than one error stratum, only the covariance structure from its lowest stratum is used in estimating standard errors. Degrees of freedom are obtained using the Satterthwaite method. In general, <code>aovList</code> support is best with balanced designs, with due caution in the use of contrasts. If a <code>vcov.</code> argument is supplied, it must yield a single covariance matrix for the unique fixed effects (not a set of them for each error stratum). In that case, the degrees of freedom are set to <code>NA</code>.</p>
<p><a href="#quickref">Back to quick reference</a></p>
<p><a href="vignette-topics.html">Index of all vignette topics</a></p>
</div>



<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
